From 87422c5c228e1ecbf9eca7cc8502f2c340199fbf Mon Sep 17 00:00:00 2001
From: David Santiago <david.santiago@gmail.com>
Date: Fri, 11 May 2012 04:22:02 -0700
Subject: [PATCH] Rewrite MultiFn to remove all locking, CLJ-988.

---
 src/jvm/clojure/lang/MultiFn.java |  195 ++++++++++++++++++++++++-------------
 1 files changed, 127 insertions(+), 68 deletions(-)

diff --git a/src/jvm/clojure/lang/MultiFn.java b/src/jvm/clojure/lang/MultiFn.java
index 1fbfc76..6a337ce 100644
--- a/src/jvm/clojure/lang/MultiFn.java
+++ b/src/jvm/clojure/lang/MultiFn.java
@@ -19,10 +19,38 @@ final public IFn dispatchFn;
 final public Object defaultDispatchVal;
 final public IRef hierarchy;
 final String name;
-IPersistentMap methodTable;
-IPersistentMap preferTable;
-IPersistentMap methodCache;
-Object cachedHierarchy;
+final Atom state;
+
+class State {
+final IPersistentMap methodTable;
+final IPersistentMap preferTable;
+final IPersistentMap methodCache;
+final Object cachedHierarchy;
+
+  public State(IPersistentMap methodTable, IPersistentMap preferTable, 
+               IPersistentMap methodCache, Object cachedHierarchy) {
+    this.methodTable = methodTable;
+    this.preferTable = preferTable;
+    this.methodCache = methodCache;
+    this.cachedHierarchy = cachedHierarchy;
+  }
+
+  public State withMethodTable(IPersistentMap methodTable) {
+    return new State(methodTable, this.preferTable, this.methodCache, this.cachedHierarchy);
+  }
+
+  public State withPreferTable(IPersistentMap preferTable) {
+    return new State(this.methodTable, preferTable, this.methodCache, this.cachedHierarchy);
+  }
+
+  public State withMethodCache(IPersistentMap methodCache) {
+    return new State(this.methodTable, this.preferTable, methodCache, this.cachedHierarchy);
+  }
+
+  public State withCachedHierarchy(Object cachedHierarchy) {
+    return new State(this.methodTable, this.preferTable, this.methodCache, cachedHierarchy);
+  }
+}
 
 static final Var assoc = RT.var("clojure.core", "assoc");
 static final Var dissoc = RT.var("clojure.core", "dissoc");
@@ -33,46 +61,62 @@ public MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hier
 	this.name = name;
 	this.dispatchFn = dispatchFn;
 	this.defaultDispatchVal = defaultDispatchVal;
-	this.methodTable = PersistentHashMap.EMPTY;
-	this.methodCache = getMethodTable();
-	this.preferTable = PersistentHashMap.EMPTY;
-    this.hierarchy = hierarchy;
-	cachedHierarchy = null;
+  this.hierarchy = hierarchy;
+
+  this.state = new Atom(new State(PersistentHashMap.EMPTY, PersistentHashMap.EMPTY, 
+                                  PersistentHashMap.EMPTY, null));
 }
 
-synchronized public MultiFn reset(){
-	methodTable = methodCache = preferTable = PersistentHashMap.EMPTY;
-	cachedHierarchy = null;
+public MultiFn reset(){
+  state.reset(new State(PersistentHashMap.EMPTY, PersistentHashMap.EMPTY, 
+                        PersistentHashMap.EMPTY, null));
 	return this;
 }
 
-synchronized public MultiFn addMethod(Object dispatchVal, IFn method) {
-	methodTable = getMethodTable().assoc(dispatchVal, method);
-	resetCache();
+public MultiFn addMethod(final Object dispatchVal, final IFn method) {
+  state.swap(new AFn() {
+    public Object invoke(Object oldState) {
+      State s = (State)oldState;
+      IPersistentMap newMethodTable = s.methodTable.assoc(dispatchVal, method);
+      return resetCache(s.withMethodTable(newMethodTable));
+    }
+  });
+  
 	return this;
 }
 
-synchronized public MultiFn removeMethod(Object dispatchVal) {
-	methodTable = getMethodTable().without(dispatchVal);
-	resetCache();
+public MultiFn removeMethod(final Object dispatchVal) {
+  state.swap(new AFn() {
+    public Object invoke(Object oldState) {
+      State s = (State)oldState;
+      IPersistentMap newMethodTable = s.methodTable.without(dispatchVal);
+      return resetCache(s.withMethodTable(newMethodTable));
+    }
+  });
 	return this;
 }
 
-synchronized public MultiFn preferMethod(Object dispatchValX, Object dispatchValY) {
-	if(prefers(dispatchValY, dispatchValX))
-		throw new IllegalStateException(
-				String.format("Preference conflict in multimethod '%s': %s is already preferred to %s",
-				              name, dispatchValY, dispatchValX));
-	preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(),
-	                                                                                     dispatchValX,
-	                                                                                     PersistentHashSet.EMPTY),
-	                                                      dispatchValY));
-	resetCache();
+public MultiFn preferMethod(final Object dispatchValX, final Object dispatchValY) {
+  state.swap(new AFn() {
+    public Object invoke(Object oldState) {
+      State s = (State)oldState;
+      if(prefers(dispatchValY, dispatchValX))
+          throw new IllegalStateException(
+            String.format("Preference conflict in multimethod '%s': %s is already preferred to %s",
+                          name, dispatchValY, dispatchValX));
+      IPersistentMap preferTable = s.preferTable.assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(s.preferTable,
+                                                                                                            dispatchValX,
+                                                                                                            PersistentHashSet.EMPTY),
+                                                                             dispatchValY));
+      return resetCache(s.withPreferTable(preferTable));
+    }
+  });
 	return this;
 }
 
 private boolean prefers(Object x, Object y) {
-	IPersistentSet xprefs = (IPersistentSet) getPreferTable().valAt(x);
+  State s = (State)state.deref();
+	IPersistentSet xprefs = (IPersistentSet)s.preferTable.valAt(x);
 	if(xprefs != null && xprefs.contains(y))
 		return true;
 	for(ISeq ps = RT.seq(parents.invoke(y)); ps != null; ps = ps.next())
@@ -96,23 +140,55 @@ private boolean dominates(Object x, Object y) {
 	return prefers(x, y) || isA(x, y);
 }
 
-private IPersistentMap resetCache() {
-	methodCache = getMethodTable();
-	cachedHierarchy = hierarchy.deref();
-	return methodCache;
+// Given a State, returns a new State with the cache reset based on the methodTable in the
+// state and the MultiFn's current hierarchy.
+private State resetCache(State s) {
+	return s.withMethodCache(s.methodTable).withCachedHierarchy(hierarchy.deref());
 }
 
-synchronized public IFn getMethod(Object dispatchVal) {
-	if(cachedHierarchy != hierarchy.deref())
-		resetCache();
-	IFn targetFn = (IFn) methodCache.valAt(dispatchVal);
-	if(targetFn != null)
-		return targetFn;
-	targetFn = findAndCacheBestMethod(dispatchVal);
-	if(targetFn != null)
-		return targetFn;
-	targetFn = (IFn) getMethodTable().valAt(defaultDispatchVal);
-	return targetFn;
+public IFn getMethod(Object dispatchVal) {
+  IFn targetFn = null;
+
+  for (;;)
+    {
+    State oldState, newState;
+    oldState = newState = (State)state.deref();
+    boolean needWrite = false;
+
+    if (newState.cachedHierarchy != hierarchy.deref()) {
+      newState = resetCache(newState);   
+      needWrite = true;
+    }
+    targetFn = (IFn)newState.methodCache.valAt(dispatchVal);
+    if (targetFn != null) {
+      // We found the method in the cache, so we can return it without more work.
+      // But, we have to make sure we either did not need to update the state's cache,
+      // or else successfully update the state with a CAS. If we need to write, but CAS failed
+      // we need to retry our work so far.
+      if (!needWrite || (needWrite && state.compareAndSet(oldState, newState)))
+        break; // essentially, return targetFn.
+      else
+        continue; // CAS failed, so we start over without doing the work below.
+    }
+
+    // The method was not found in the method cache, so we must look it up and update the
+    // cache if we find it.
+    targetFn = findBestMethod(newState, dispatchVal);
+    if (targetFn != null) {
+        newState = newState.withMethodCache(newState.methodCache.assoc(dispatchVal, targetFn));
+        if (newState.cachedHierarchy == hierarchy.deref()
+            && state.compareAndSet(oldState, newState))
+          break;
+        else 
+          continue; // again, skip over the pointless work below, since we must retry.
+    }
+
+    // Finally, we failed to find the method elsewhere, so use the default dispatch value.
+    targetFn = (IFn)newState.methodTable.valAt(defaultDispatchVal);
+    break;
+    }
+
+  return targetFn;
 }
 
 private IFn getFn(Object dispatchVal) {
@@ -123,9 +199,9 @@ private IFn getFn(Object dispatchVal) {
 	return targetFn;
 }
 
-private IFn findAndCacheBestMethod(Object dispatchVal) {
+private IFn findBestMethod(State s, Object dispatchVal) {
 	Map.Entry bestEntry = null;
-	for(Object o : getMethodTable())
+	for(Object o : s.methodTable)
 		{
 		Map.Entry e = (Map.Entry) o;
 		if(isA(dispatchVal, e.getKey()))
@@ -139,20 +215,11 @@ private IFn findAndCacheBestMethod(Object dispatchVal) {
 								name, dispatchVal, e.getKey(), bestEntry.getKey()));
 			}
 		}
-	if(bestEntry == null)
-		return null;
-	//ensure basis has stayed stable throughout, else redo
-	if(cachedHierarchy == hierarchy.deref())
-		{
-		//place in cache
-		methodCache = methodCache.assoc(dispatchVal, bestEntry.getValue());
-		return (IFn) bestEntry.getValue();
-		}
-	else
-		{
-		resetCache();
-		return findAndCacheBestMethod(dispatchVal);
-		}
+
+  if (bestEntry != null)
+      return (IFn)bestEntry.getValue();
+  else
+      return null;
 }
 
 public Object invoke() {
@@ -509,12 +576,4 @@ public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object
                                Util.ret1(arg20,arg20=null),
                                args);
 }
-
-    public IPersistentMap getMethodTable() {
-        return methodTable;
-    }
-
-    public IPersistentMap getPreferTable() {
-        return preferTable;
-    }
 }
-- 
1.7.2.2

