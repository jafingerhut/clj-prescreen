From 9c7bccc10fc7b4f052b77e94ae4ba15bb7dbf641 Mon Sep 17 00:00:00 2001
From: Jim Blomo <jim.blomo+github@gmail.com>
Date: Sat, 28 Apr 2012 08:43:37 -0700
Subject: [PATCH 1/4] ignore vim swap files

---
 .gitignore |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/.gitignore b/.gitignore
index 2f67a91..80911eb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,5 @@
 *.jar
+*.sw[po]
 target
 clojure.iws
 clojure.ipr
-- 
1.7.1


From a35979f741e8091e5602f455c455e150283be7c6 Mon Sep 17 00:00:00 2001
From: Jim Blomo <jim.blomo+github@gmail.com>
Date: Sat, 28 Apr 2012 08:44:09 -0700
Subject: [PATCH 2/4] initial subMap implementation

---
 src/jvm/clojure/lang/APersistentMap.java    |  188 +++++++++++++++++++++++++++
 src/jvm/clojure/lang/PersistentTreeMap.java |   22 +++-
 2 files changed, 209 insertions(+), 1 deletions(-)

diff --git a/src/jvm/clojure/lang/APersistentMap.java b/src/jvm/clojure/lang/APersistentMap.java
index 205b867..5c37039 100644
--- a/src/jvm/clojure/lang/APersistentMap.java
+++ b/src/jvm/clojure/lang/APersistentMap.java
@@ -392,4 +392,192 @@ public boolean contains(Object o){
 	return false;
 }
 */
+public class SubPersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, SortedMap{
+	final IPersistentMap m; // must be Sorted
+	final Object start;
+	final Object end;
+	final IPersistentMap _meta;
+
+	public SubPersistentTreeMap(IPersistentMap meta, IPersistentMap m, Object start, Object end){
+		this._meta = meta;
+
+		if(!(m implements Sorted)) {
+			throw new IllegalArgumentException("IPersistentMap arg to SubPersistentTreeMap must be Sorted");
+		}
+
+		if(m instanceof APersistentMap.SubPersistentTreeMap) {
+			APersistentMap.SubPersistentTreeMap sm = (APersistentMap.SubPersistentTreeMap) m;
+			m = sm.m;
+		}
+		this.m = m;
+		this.start = start;
+		this.end = end;
+	}
+
+	private withinSubRange(Object key){
+		return (m.doCompare(key, start) >= 0) &&
+			((end == null) || (m.doCompare(key, end) < 0));
+	}
+
+	public boolean containsKey(Object key){
+		return entryAt(key) != null;
+	}
+
+	public Node entryAt(Object key){
+		return withinSubRange(key) ? m.entryAt(key) : null;
+	}
+
+	public IPersistentMap assocEx(Object key, Object val) {
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.assocEx(key, val), start, end);
+
+		// else we're not inserting between the range, so we no longer have a submap
+		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
+	}
+
+	public PersistentTreeMap assoc(Object key, Object val){
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.assoc(key, val), start, end);
+
+		// else we're not inserting between the range, so we no longer have a submap
+		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
+	}
+
+	public PersistentTreeMap without(Object key){
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.without(key), start, end);
+
+		return this;
+	}
+
+	public IPersistentCollection empty(){
+		return m.empty();
+	}
+
+	public ISeq rseq() {
+		return seqFrom(start, false);
+	}
+
+	public Comparator comparator(){
+		return m.comp;
+	}
+
+	public Object firstKey(){
+		// TODO binary search
+		return RT.first(seqFrom(start, true)).key();
+	}
+
+	public SortedMap headMap(Object toKey){
+		if((end == null) || (m.doCompare(toKey, end) >= 0))
+			return this;
+
+		return new SubPersistentTreeMap(meta(), m, start, toKey);
+	}
+
+	public Object lastKey(){
+		if(end)
+			// TODO binary search
+			return RT.first(rseq()).key();
+
+		return m.lastKey();
+	}
+
+	public SortedMap subMap(Object fromKey, Object toKey){
+		Object newStart = m.doCompare(fromKey, start) > 0 ? fromKey : start;
+		Object newEnd = ((end == null) || (m.doCompare(toKey, end))) < 0 ? toKey : end;
+
+		if(m.doCompare(newEnd, newStart) <= 0)
+			return m.empty();
+
+		return new SubPersistentTreeMap(meta(), this, newStart, newEnd);
+	}
+
+	public SortedMap tailMap(Object fromKey){
+		if(m.doCompare(fromKey, start) <= 0)
+			return this;
+
+		return new SubPersistentTreeMap(meta(), this, fromKey, end);
+	}
+
+	public ISeq seq(boolean ascending){
+		return seqFrom(start, ascending);
+	}
+
+	public ISeq seqFrom(Object key, boolean ascending){
+		if(ascending && (end != null) && (m.doCompare(key, end) >= 0))
+			return null;
+
+		if(!ascending && m.doCompare(key, start) < 0)
+			return null;
+
+		if((m._count > 0)) {
+
+			ISeq stack = null;
+			Node t = m.tree;
+			while(t != null) {
+				int c = m.doCompare(key, t.key);
+				if(c == 0) {
+					stack = RT.cons(t, stack);
+					return new Seq(stack, ascending);
+				}
+				else if(ascending) {
+					if((end != null) && (m.doCompare(t.key, end) >= 0)) {
+						stack = RT.cons(t, stack);
+						return new Seq(stack, ascending);
+					} else if(c < 0) {
+						stack = RT.cons(t, stack);
+						t = t.left();
+					}
+					else
+						t = t.right();
+
+				} else { // descending
+					if(m.doCompare(start, t.key) < 0) {
+						stack = RT.cons(t, stack);
+						return new Seq(stack, ascending);
+					} else {
+						if(c > 0) {
+							stack = RT.cons(t, stack);
+							t = t.right();
+						} else
+							t = t.left();
+					}
+				}
+			}
+			if(stack != null)
+				return new Seq(stack, ascending);
+		}
+		return null;
+	}
+
+	public Iterator iterator(){
+		return seq(true).iterator();
+	}
+
+	public NodeIterator reverseIterator(){
+		return rseq(true).iterator();
+	}
+
+	public Iterator keys(){
+		return keys(iterator());
+	}
+
+	public Iterator vals(){
+		return vals(iterator());
+	}
+
+	public Object valAt(Object key, Object notFound){
+		return withinSubRange(key) ? m.valAt(key, notFound) : notFound;
+	}
+
+	public Object valAt(Object key){
+		return withinSubRange(key) ? m.valAt(key) : null;
+	}
+
+	public int count(){
+		// TODO memoize?
+		return seq(true).count();
+	}
+}
 }
+// TODO enclose SubPersistentTreeMap in scope
diff --git a/src/jvm/clojure/lang/PersistentTreeMap.java b/src/jvm/clojure/lang/PersistentTreeMap.java
index 46c15da..8a636a5 100644
--- a/src/jvm/clojure/lang/PersistentTreeMap.java
+++ b/src/jvm/clojure/lang/PersistentTreeMap.java
@@ -22,7 +22,7 @@ import java.util.*;
  * See Okasaki, Kahrs, Larsen et al
  */
 
-public class PersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted{
+public class PersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, SortedMap{
 
 public final Comparator comp;
 public final Node tree;
@@ -151,6 +151,26 @@ public Comparator comparator(){
 	return comp;
 }
 
+public Object firstKey(){
+	return minKey();
+}
+
+public SortedMap headMap(Object toKey){
+	return APersistentMap.SubPersistentTreeMap(meta(), this, firstKey(), toKey);
+}
+
+public Object lastKey(){
+	return maxKey();
+}
+
+public SortedMap subMap(Object fromKey, Object toKey){
+	return new APersistentMap.SubPersistentTreeMap(meta(), this, fromKey, toKey);
+}
+
+public SortedMap tailMap(Object fromKey){
+	return new APersistentMap.SubPersistentTreeMap(meta(), this, fromKey, null);
+}
+
 public Object entryKey(Object entry){
 	return ((IMapEntry) entry).key();
 }
-- 
1.7.1


From b6716f71fcc3a54f4224df6cbbf0027943f81bb2 Mon Sep 17 00:00:00 2001
From: Jim Blomo <jim.blomo+github@gmail.com>
Date: Sat, 28 Apr 2012 10:16:40 -0700
Subject: [PATCH 3/4] submap compiling

---
 src/jvm/clojure/lang/APersistentMap.java    |  188 --------------------------
 src/jvm/clojure/lang/PersistentTreeMap.java |  194 ++++++++++++++++++++++++++-
 2 files changed, 191 insertions(+), 191 deletions(-)

diff --git a/src/jvm/clojure/lang/APersistentMap.java b/src/jvm/clojure/lang/APersistentMap.java
index 5c37039..205b867 100644
--- a/src/jvm/clojure/lang/APersistentMap.java
+++ b/src/jvm/clojure/lang/APersistentMap.java
@@ -392,192 +392,4 @@ public boolean contains(Object o){
 	return false;
 }
 */
-public class SubPersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, SortedMap{
-	final IPersistentMap m; // must be Sorted
-	final Object start;
-	final Object end;
-	final IPersistentMap _meta;
-
-	public SubPersistentTreeMap(IPersistentMap meta, IPersistentMap m, Object start, Object end){
-		this._meta = meta;
-
-		if(!(m implements Sorted)) {
-			throw new IllegalArgumentException("IPersistentMap arg to SubPersistentTreeMap must be Sorted");
-		}
-
-		if(m instanceof APersistentMap.SubPersistentTreeMap) {
-			APersistentMap.SubPersistentTreeMap sm = (APersistentMap.SubPersistentTreeMap) m;
-			m = sm.m;
-		}
-		this.m = m;
-		this.start = start;
-		this.end = end;
-	}
-
-	private withinSubRange(Object key){
-		return (m.doCompare(key, start) >= 0) &&
-			((end == null) || (m.doCompare(key, end) < 0));
-	}
-
-	public boolean containsKey(Object key){
-		return entryAt(key) != null;
-	}
-
-	public Node entryAt(Object key){
-		return withinSubRange(key) ? m.entryAt(key) : null;
-	}
-
-	public IPersistentMap assocEx(Object key, Object val) {
-		if(withinSubRange(key))
-			return new SubPersistentTreeMap(meta(), m.assocEx(key, val), start, end);
-
-		// else we're not inserting between the range, so we no longer have a submap
-		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
-	}
-
-	public PersistentTreeMap assoc(Object key, Object val){
-		if(withinSubRange(key))
-			return new SubPersistentTreeMap(meta(), m.assoc(key, val), start, end);
-
-		// else we're not inserting between the range, so we no longer have a submap
-		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
-	}
-
-	public PersistentTreeMap without(Object key){
-		if(withinSubRange(key))
-			return new SubPersistentTreeMap(meta(), m.without(key), start, end);
-
-		return this;
-	}
-
-	public IPersistentCollection empty(){
-		return m.empty();
-	}
-
-	public ISeq rseq() {
-		return seqFrom(start, false);
-	}
-
-	public Comparator comparator(){
-		return m.comp;
-	}
-
-	public Object firstKey(){
-		// TODO binary search
-		return RT.first(seqFrom(start, true)).key();
-	}
-
-	public SortedMap headMap(Object toKey){
-		if((end == null) || (m.doCompare(toKey, end) >= 0))
-			return this;
-
-		return new SubPersistentTreeMap(meta(), m, start, toKey);
-	}
-
-	public Object lastKey(){
-		if(end)
-			// TODO binary search
-			return RT.first(rseq()).key();
-
-		return m.lastKey();
-	}
-
-	public SortedMap subMap(Object fromKey, Object toKey){
-		Object newStart = m.doCompare(fromKey, start) > 0 ? fromKey : start;
-		Object newEnd = ((end == null) || (m.doCompare(toKey, end))) < 0 ? toKey : end;
-
-		if(m.doCompare(newEnd, newStart) <= 0)
-			return m.empty();
-
-		return new SubPersistentTreeMap(meta(), this, newStart, newEnd);
-	}
-
-	public SortedMap tailMap(Object fromKey){
-		if(m.doCompare(fromKey, start) <= 0)
-			return this;
-
-		return new SubPersistentTreeMap(meta(), this, fromKey, end);
-	}
-
-	public ISeq seq(boolean ascending){
-		return seqFrom(start, ascending);
-	}
-
-	public ISeq seqFrom(Object key, boolean ascending){
-		if(ascending && (end != null) && (m.doCompare(key, end) >= 0))
-			return null;
-
-		if(!ascending && m.doCompare(key, start) < 0)
-			return null;
-
-		if((m._count > 0)) {
-
-			ISeq stack = null;
-			Node t = m.tree;
-			while(t != null) {
-				int c = m.doCompare(key, t.key);
-				if(c == 0) {
-					stack = RT.cons(t, stack);
-					return new Seq(stack, ascending);
-				}
-				else if(ascending) {
-					if((end != null) && (m.doCompare(t.key, end) >= 0)) {
-						stack = RT.cons(t, stack);
-						return new Seq(stack, ascending);
-					} else if(c < 0) {
-						stack = RT.cons(t, stack);
-						t = t.left();
-					}
-					else
-						t = t.right();
-
-				} else { // descending
-					if(m.doCompare(start, t.key) < 0) {
-						stack = RT.cons(t, stack);
-						return new Seq(stack, ascending);
-					} else {
-						if(c > 0) {
-							stack = RT.cons(t, stack);
-							t = t.right();
-						} else
-							t = t.left();
-					}
-				}
-			}
-			if(stack != null)
-				return new Seq(stack, ascending);
-		}
-		return null;
-	}
-
-	public Iterator iterator(){
-		return seq(true).iterator();
-	}
-
-	public NodeIterator reverseIterator(){
-		return rseq(true).iterator();
-	}
-
-	public Iterator keys(){
-		return keys(iterator());
-	}
-
-	public Iterator vals(){
-		return vals(iterator());
-	}
-
-	public Object valAt(Object key, Object notFound){
-		return withinSubRange(key) ? m.valAt(key, notFound) : notFound;
-	}
-
-	public Object valAt(Object key){
-		return withinSubRange(key) ? m.valAt(key) : null;
-	}
-
-	public int count(){
-		// TODO memoize?
-		return seq(true).count();
-	}
-}
 }
-// TODO enclose SubPersistentTreeMap in scope
diff --git a/src/jvm/clojure/lang/PersistentTreeMap.java b/src/jvm/clojure/lang/PersistentTreeMap.java
index 8a636a5..4c5dc9e 100644
--- a/src/jvm/clojure/lang/PersistentTreeMap.java
+++ b/src/jvm/clojure/lang/PersistentTreeMap.java
@@ -156,7 +156,7 @@ public Object firstKey(){
 }
 
 public SortedMap headMap(Object toKey){
-	return APersistentMap.SubPersistentTreeMap(meta(), this, firstKey(), toKey);
+	return new SubPersistentTreeMap(meta(), this, firstKey(), toKey);
 }
 
 public Object lastKey(){
@@ -164,11 +164,11 @@ public Object lastKey(){
 }
 
 public SortedMap subMap(Object fromKey, Object toKey){
-	return new APersistentMap.SubPersistentTreeMap(meta(), this, fromKey, toKey);
+	return new SubPersistentTreeMap(meta(), this, fromKey, toKey);
 }
 
 public SortedMap tailMap(Object fromKey){
-	return new APersistentMap.SubPersistentTreeMap(meta(), this, fromKey, null);
+	return new SubPersistentTreeMap(meta(), this, fromKey, null);
 }
 
 public Object entryKey(Object entry){
@@ -915,6 +915,194 @@ static class ValIterator implements Iterator{
 		throw new UnsupportedOperationException();
 	}
 }
+
+public class SubPersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, SortedMap{
+	final PersistentTreeMap m;
+	final Object start;
+	final Object end;
+	final IPersistentMap _meta;
+
+	public SubPersistentTreeMap(IPersistentMap meta, PersistentTreeMap m, Object start, Object end){
+		this._meta = meta;
+
+		this.m = m;
+		this.start = start;
+		this.end = end;
+	}
+
+	private boolean withinSubRange(Object key){
+		return (m.doCompare(key, start) >= 0) &&
+			((end == null) || (m.doCompare(key, end) < 0));
+	}
+
+	public IPersistentMap meta(){
+		return _meta;
+	}
+
+	public IObj withMeta(IPersistentMap meta){
+		return new SubPersistentTreeMap(meta, m, start, end);
+	}
+
+	public boolean containsKey(Object key){
+		return entryAt(key) != null;
+	}
+
+	public IMapEntry entryAt(Object key){
+		return withinSubRange(key) ? m.entryAt(key) : null;
+	}
+
+	public Object entryKey(Object entry){
+		return ((IMapEntry) entry).key();
+	}
+
+	public IPersistentMap assocEx(Object key, Object val) {
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.assocEx(key, val), start, end);
+
+		// else we're not inserting between the range, so we no longer have a submap
+		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
+	}
+
+	public IPersistentMap assoc(Object key, Object val){
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.assoc(key, val), start, end);
+
+		// else we're not inserting between the range, so we no longer have a submap
+		return PersistentTreeMap.create(comparator(), seq(true)).assocEx(key, val);
+	}
+
+	public IPersistentMap without(Object key){
+		if(withinSubRange(key))
+			return new SubPersistentTreeMap(meta(), m.without(key), start, end);
+
+		return this;
+	}
+
+	public IPersistentCollection empty(){
+		return m.empty();
+	}
+
+	public ASeq rseq() {
+		return seqFrom(start, false);
+	}
+
+	public Comparator comparator(){
+		return m.comparator();
+	}
+
+	public Object firstKey(){
+		// TODO binary search
+		return ((IMapEntry)RT.first(seqFrom(start, true))).key();
+	}
+
+	public SortedMap headMap(Object toKey){
+		if((end == null) || (m.doCompare(toKey, end) >= 0))
+			return this;
+
+		return new SubPersistentTreeMap(meta(), m, start, toKey);
+	}
+
+	public Object lastKey(){
+		if(end == null)
+			return m.lastKey();
+
+		// TODO binary search
+		return ((IMapEntry)RT.first(rseq())).key();
+	}
+
+	public SortedMap subMap(Object fromKey, Object toKey){
+		Object newStart = m.doCompare(fromKey, start) > 0 ? fromKey : start;
+		Object newEnd = ((end == null) || (m.doCompare(toKey, end)) < 0) ? toKey : end;
+
+		if(m.doCompare(newEnd, newStart) <= 0)
+			return new PersistentTreeMap(meta(), comparator());	
+
+		return new SubPersistentTreeMap(meta(), m, newStart, newEnd);
+	}
+
+	public SortedMap tailMap(Object fromKey){
+		if(m.doCompare(fromKey, start) <= 0)
+			return this;
+
+		return new SubPersistentTreeMap(meta(), m, fromKey, end);
+	}
+
+	public ASeq seq(){
+		return seqFrom(start, true);
+	}
+
+	public ASeq seq(boolean ascending){
+		return seqFrom(start, ascending);
+	}
+
+	public ASeq seqFrom(Object key, boolean ascending){
+		if(ascending && (end != null) && (m.doCompare(key, end) >= 0))
+			return null;
+
+		if(!ascending && m.doCompare(key, start) < 0)
+			return null;
+
+		if((m._count > 0)) {
+
+			ISeq stack = null;
+			Node t = m.tree;
+			while(t != null) {
+				int c = m.doCompare(key, t.key);
+				if(c == 0) {
+					stack = RT.cons(t, stack);
+					return new Seq(stack, ascending);
+				}
+				else if(ascending) {
+					if((end != null) && (m.doCompare(t.key, end) >= 0)) {
+						stack = RT.cons(t, stack);
+						return new Seq(stack, ascending);
+					} else if(c < 0) {
+						stack = RT.cons(t, stack);
+						t = t.left();
+					}
+					else
+						t = t.right();
+
+				} else { // descending
+					if(m.doCompare(start, t.key) < 0) {
+						stack = RT.cons(t, stack);
+						return new Seq(stack, ascending);
+					} else {
+						if(c > 0) {
+							stack = RT.cons(t, stack);
+							t = t.right();
+						} else
+							t = t.left();
+					}
+				}
+			}
+			if(stack != null)
+				return new Seq(stack, ascending);
+		}
+		return null;
+	}
+
+	public Iterator iterator(){
+		return seq().iterator();
+	}
+
+	public Iterator reverseIterator(){
+		return rseq().iterator();
+	}
+
+	public Object valAt(Object key, Object notFound){
+		return withinSubRange(key) ? m.valAt(key, notFound) : notFound;
+	}
+
+	public Object valAt(Object key){
+		return withinSubRange(key) ? m.valAt(key) : null;
+	}
+
+	public int count(){
+		// TODO memoize?
+		return seq(true).count();
+	}
+}
 /*
 static public void main(String args[]){
 	if(args.length != 1)
-- 
1.7.1


From 7081aaabbf6f5a10a3f4ba89555014cd5b7876af Mon Sep 17 00:00:00 2001
From: Jim Blomo <jim.blomo+github@gmail.com>
Date: Thu, 10 May 2012 23:06:52 -0700
Subject: [PATCH 4/4] seqFrom working on submaps

---
 src/jvm/clojure/lang/PersistentTreeMap.java |  102 +++++++++++++++++----------
 1 files changed, 65 insertions(+), 37 deletions(-)

diff --git a/src/jvm/clojure/lang/PersistentTreeMap.java b/src/jvm/clojure/lang/PersistentTreeMap.java
index 4c5dc9e..1cfb281 100644
--- a/src/jvm/clojure/lang/PersistentTreeMap.java
+++ b/src/jvm/clojure/lang/PersistentTreeMap.java
@@ -156,7 +156,7 @@ public Object firstKey(){
 }
 
 public SortedMap headMap(Object toKey){
-	return new SubPersistentTreeMap(meta(), this, firstKey(), toKey);
+	return new SubPersistentTreeMap(meta(), this, minKey(), toKey);
 }
 
 public Object lastKey(){
@@ -181,7 +181,7 @@ public ISeq seq(boolean ascending){
 	return null;
 }
 
-public ISeq seqFrom(Object key, boolean ascending){
+public ASeq seqFrom(Object key, boolean ascending){
 	if(_count > 0)
 		{
 		ISeq stack = null;
@@ -1036,50 +1036,78 @@ public class SubPersistentTreeMap extends APersistentMap implements IObj, Revers
 	}
 
 	public ASeq seqFrom(Object key, boolean ascending){
-		if(ascending && (end != null) && (m.doCompare(key, end) >= 0))
-			return null;
+		if(ascending) {
+			Object seqStart = m.doCompare(start, key) > 0 ? start : key;
+			ASeq seq = m.seqFrom(seqStart, ascending);
+			if(seq == null)
+				return null;
+			final Iterator mi = seq.iterator();
+
+			return IteratorSeq.create(new Iterator() {
+				Node next = (Node)mi.next();
+				public boolean hasNext() {
+					return next != null && (end == null || m.doCompare(next.key, end) < 0);
+				}
 
-		if(!ascending && m.doCompare(key, start) < 0)
-			return null;
+				public Object next() {
+					if(!hasNext())
+						throw new NoSuchElementException();
 
-		if((m._count > 0)) {
+					Object ret = next;
+					if(mi.hasNext()) {
+						next = (Node)mi.next();
+					} else {
+						next = null;
+					}
+					return ret;
+				}
 
-			ISeq stack = null;
-			Node t = m.tree;
-			while(t != null) {
-				int c = m.doCompare(key, t.key);
-				if(c == 0) {
-					stack = RT.cons(t, stack);
-					return new Seq(stack, ascending);
+				public void remove() {
+					throw new UnsupportedOperationException();
 				}
-				else if(ascending) {
-					if((end != null) && (m.doCompare(t.key, end) >= 0)) {
-						stack = RT.cons(t, stack);
-						return new Seq(stack, ascending);
-					} else if(c < 0) {
-						stack = RT.cons(t, stack);
-						t = t.left();
-					}
-					else
-						t = t.right();
+			});
+
+		} else { // descending
+			Object seqStart = (end != null && m.doCompare(end, key) < 0) ? end : key;
+			ASeq seq = m.seqFrom(seqStart, ascending);
+			if(seq == null)
+				return null;
+			final Iterator mi = seq.iterator();
+
+			Node startNode = null;
+			// make sure to exclude end
+			while(startNode == null && mi.hasNext()) {
+				Node test = (Node)mi.next();
+				if(end == null || m.doCompare(test.key, end) < 0)
+					startNode = test;
+			}
+			// alllow annonymous class to access startNode
+			final Node fStartNode = startNode;
 
-				} else { // descending
-					if(m.doCompare(start, t.key) < 0) {
-						stack = RT.cons(t, stack);
-						return new Seq(stack, ascending);
+			return IteratorSeq.create(new Iterator() {
+				Node next = fStartNode;
+				public boolean hasNext() {
+					return next != null && m.doCompare(next.key, start) >= 0;
+				}
+
+				public Object next() {
+					if(!hasNext())
+						throw new NoSuchElementException();
+
+					Object ret = next;
+					if(mi.hasNext()) {
+						next = (Node)mi.next();
 					} else {
-						if(c > 0) {
-							stack = RT.cons(t, stack);
-							t = t.right();
-						} else
-							t = t.left();
+						next = null;
 					}
+					return ret;
 				}
-			}
-			if(stack != null)
-				return new Seq(stack, ascending);
+
+				public void remove() {
+					throw new UnsupportedOperationException();
+				}
+			});
 		}
-		return null;
 	}
 
 	public Iterator iterator(){
-- 
1.7.1

