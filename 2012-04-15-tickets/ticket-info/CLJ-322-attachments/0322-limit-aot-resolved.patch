From fbef85dc663c89bcc86c532b2ae2a772f9680597 Mon Sep 17 00:00:00 2001
From: Chas Emerick <cemerick@snowtide.com>
Date: Wed, 23 Jun 2010 13:32:06 -0400
Subject: [PATCH] disable AOT compilation transitivity by default; fixes CLJ-322

Signed-off-by: Stuart Halloway <stu@thinkrelevance.com>
---
 build.xml                                 |    8 +++++++
 src/clj/clojure/core.clj                  |   18 +++++++++++++--
 src/clj/clojure/main.clj                  |    7 +++--
 src/jvm/clojure/lang/Compile.java         |    9 +++++--
 src/jvm/clojure/lang/Compiler.java        |   32 +++++++++++++++++++++++++++-
 src/jvm/clojure/lang/RT.java              |    2 +-
 test/clojure/test_clojure/compilation.clj |   16 +++++++++++++-
 7 files changed, 79 insertions(+), 13 deletions(-)

diff --git a/build.xml b/build.xml
index e7261e5..ac557ce 100644
--- a/build.xml
+++ b/build.xml
@@ -138,6 +138,14 @@
       <sysproperty key="clojure.compile.path" value="${test-classes}"/>
       <arg value="clojure.test-clojure.protocols.examples"/>
       <arg value="clojure.test-clojure.genclass.examples"/>
+      <arg value="clojure.test-clojure.aot.nontransitive"/>
+    </java>
+    <java classname="clojure.lang.Compile"
+          classpath="${test-classes}:${test}:${build}:${cljsrc}"
+          failonerror="true">
+      <sysproperty key="clojure.compile.path" value="${test-classes}"/>
+      <sysproperty key="clojure.compile.transitive" value="true"/>
+      <arg value="clojure.test-clojure.aot.transitive"/>
     </java>
   </target>
 
diff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj
index ed24019..0978552 100644
--- a/src/clj/clojure/core.clj
+++ b/src/clj/clojure/core.clj
@@ -5334,7 +5334,8 @@
   {:added "1.0"}
 
   [& args]
-  (apply load-libs :require args))
+  (binding [*load-level* (inc *load-level*)]
+    (apply load-libs :require args)))
 
 (defn use
   "Like 'require, but also refers to each lib's namespace using
@@ -5345,7 +5346,9 @@
   The arguments and semantics for :exclude, :only, and :rename are the same
   as those documented for clojure.core/refer."
   {:added "1.0"}
-  [& args] (apply load-libs :require :use args))
+  [& args]
+  (binding [*load-level* (inc *load-level*)]
+    (apply load-libs :require :use args)))
 
 (defn loaded-libs
   "Returns a sorted set of symbols naming the currently loaded libs"
@@ -5380,7 +5383,8 @@
   be in the classpath."
   {:added "1.0"}
   [lib]
-  (binding [*compile-files* true]
+  (binding [*compile-files* true
+            *load-level* (inc *load-level*)]
     (load-one lib true true))
   lib)
 
@@ -5656,6 +5660,14 @@
   Defaults to \"classes\""
   {:added "1.0"})
 
+(add-doc-and-meta *transitive-compile*
+  "When false (the default), classfiles will be written only for
+   namespaces explicitly provided to 'compile'.
+   Otherwise, classfiles will be saved to disk
+   in *compile-path* for all namespaces loaded by the namespace
+   provided to 'compile', whether directly or transitively."
+  {:added "1.3"})
+
 (add-doc-and-meta *compile-files*
   "Set to true when compiling files, false otherwise."
   {:added "1.0"})
diff --git a/src/clj/clojure/main.clj b/src/clj/clojure/main.clj
index 96fa25b..51efecd 100644
--- a/src/clj/clojure/main.clj
+++ b/src/clj/clojure/main.clj
@@ -12,7 +12,7 @@
        :author "Stephen C. Gilardi and Rich Hickey"}
   clojure.main
   (:refer-clojure :exclude [with-bindings])
-  (:import (clojure.lang Compiler Compiler$CompilerException
+  (:import (clojure.lang Compiler Compile Compiler$CompilerException
                          LineNumberingPushbackReader RT))
   (:use [clojure.repl :only (demunge root-cause stack-element-str)]))
 
@@ -21,16 +21,17 @@
 (defmacro with-bindings
   "Executes body in the context of thread-local bindings for several vars
   that often need to be set!: *ns* *warn-on-reflection* *math-context*
-  *print-meta* *print-length* *print-level* *compile-path*
+  *print-meta* *print-length* *print-level* *compile-path* *transitive-compile*
   *command-line-args* *1 *2 *3 *e"
   [& body]
   `(binding [*ns* *ns*
              *warn-on-reflection* *warn-on-reflection*
+             *compile-path* (System/getProperty Compile/PATH_PROP "classes")
+             *transitive-compile* *transitive-compile*
              *math-context* *math-context*
              *print-meta* *print-meta*
              *print-length* *print-length*
              *print-level* *print-level*
-             *compile-path* (System/getProperty "clojure.compile.path" "classes")
              *command-line-args* *command-line-args*
              *unchecked-math* *unchecked-math*
              *assert* *assert*
diff --git a/src/jvm/clojure/lang/Compile.java b/src/jvm/clojure/lang/Compile.java
index 81d1c81..668e74a 100644
--- a/src/jvm/clojure/lang/Compile.java
+++ b/src/jvm/clojure/lang/Compile.java
@@ -22,8 +22,9 @@ import java.io.IOException;
 
 public class Compile{
 
-private static final String PATH_PROP = "clojure.compile.path";
+public static final String PATH_PROP = "clojure.compile.path";
 private static final String REFLECTION_WARNING_PROP = "clojure.compile.warn-on-reflection";
+public static final String TRANSITIVE_PROP = "clojure.compile.transitive";
 private static final Var compile_path = RT.var("clojure.core", "*compile-path*");
 private static final Var compile = RT.var("clojure.core", "compile");
 private static final Var warn_on_reflection = RT.var("clojure.core", "*warn-on-reflection*");
@@ -44,14 +45,16 @@ public static void main(String[] args) throws Exception{
 		}
 
     boolean warnOnReflection = System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true");
+    boolean transitive = System.getProperty(TRANSITIVE_PROP, "false").equals("true");
 
 	try
 		{
-		Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection));
+		Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection,
+                Compiler.TRANSITIVE_COMPILE, transitive));
 
 		for(String lib : args)
         {
-            out.write("Compiling " + lib + " to " + path + "\n");
+            out.write((transitive ? "Transitively c" : "C") + "ompiling " + lib + " to " + path + "\n");
             out.flush();
             compile.invoke(Symbol.intern(lib));
         }
diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 9794d64..111be1d 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -231,6 +231,16 @@ static final public Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol
 static final public Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")),
                                             Symbol.intern("instance?"));
 
+/**
+ * Current value is how many require/use/compile usages we are from the top level require/use/compile usage.
+ * Used to determine whether or not to emit classfiles when {@link #TRANSITIVE_COMPILE} is false.
+ */
+static final public Var LOAD_LEVEL = Var.intern(Namespace.findOrCreate(Symbol.create("clojure.core")),
+                                                Symbol.create("*load-level*"), new Integer(0)).setDynamic();
+
+static final public Var TRANSITIVE_COMPILE = Var.intern(Namespace.findOrCreate(Symbol.create("clojure.core")),
+                                                        Symbol.create("*transitive-compile*"), Boolean.FALSE).setDynamic();
+
 static final public Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")),
                                             Symbol.intern("add-annotations"));
 
@@ -255,6 +265,14 @@ static final public Var RET_LOCAL_NUM = Var.create().setDynamic();
 static final public Var COMPILE_STUB_SYM = Var.create(null).setDynamic();
 static final public Var COMPILE_STUB_CLASS = Var.create(null).setDynamic();
 
+/**
+ * Returns true only if the current load/compilation process should
+ * emit a compiled classfile to disk.
+ */
+static boolean writeClassFiles () {
+    return RT.booleanCast(COMPILE_FILES.deref()) &&
+            (RT.booleanCast(TRANSITIVE_COMPILE.deref()) || 1L == (Long)LOAD_LEVEL.deref());
+}
 
 //PathNode chain
 static final public Var CLEAR_PATH = Var.create(null).setDynamic();
@@ -4052,8 +4070,9 @@ static public class ObjExpr implements Expr{
 		cv.visitEnd();
 
 		bytecode = cw.toByteArray();
-		if(RT.booleanCast(COMPILE_FILES.deref()))
-			writeClassFile(internalName, bytecode);
+        // guard not necessary here, just not sure of the status of the commented getCompiledClass below
+		if(writeClassFiles())
+            writeClassFile(internalName, bytecode);
 //		else
 //			getCompiledClass();
 	}
@@ -6648,6 +6667,14 @@ public static Object load(Reader rdr, String sourcePath, String sourceName) thro
 }
 
 static public void writeClassFile(String internalName, byte[] bytecode) throws Exception{
+    // guard for proxy, gen-class, etc.
+    if (!writeClassFiles()) {
+        // if we're not going to write the class file, we need to load the code so that
+        // later imports will succeed
+        ((DynamicClassLoader)LOADER.deref()).defineClass(internalName.replace('/', '.'), bytecode, null);
+        return;
+    }
+
 	String genPath = (String) COMPILE_PATH.deref();
 	if(genPath == null)
 		throw new Exception("*compile-path* not set");
@@ -6720,6 +6747,7 @@ static void compile1(GeneratorAdapter gen, ObjExpr objx, Object form) throws Exc
 public static Object compile(Reader rdr, String sourcePath, String sourceName) throws Exception{
 	if(COMPILE_PATH.deref() == null)
 		throw new Exception("*compile-path* not set");
+    if(!writeClassFiles()) load(rdr, sourcePath, sourceName);
 
 	Object EOF = new Object();
 	Object ret = null;
diff --git a/src/jvm/clojure/lang/RT.java b/src/jvm/clojure/lang/RT.java
index 086a3a6..e56eede 100644
--- a/src/jvm/clojure/lang/RT.java
+++ b/src/jvm/clojure/lang/RT.java
@@ -403,7 +403,7 @@ static public void load(String scriptbase, boolean failIfNotFound) throws Except
 		}
 	}
 	if(!loaded && cljURL != null) {
-		if(booleanCast(Compiler.COMPILE_FILES.deref()))
+		if(Compiler.writeClassFiles())
 			compile(cljfile);
 		else
 			loadResourceScript(RT.class, cljfile);
diff --git a/test/clojure/test_clojure/compilation.clj b/test/clojure/test_clojure/compilation.clj
index 1781460..d6d7fe7 100644
--- a/test/clojure/test_clojure/compilation.clj
+++ b/test/clojure/test_clojure/compilation.clj
@@ -10,7 +10,8 @@
 
 
 (ns clojure.test-clojure.compilation
-  (:use clojure.test))
+  (:use clojure.test
+    [clojure.java.io :as io :only ()]))
 
 ; http://clojure.org/compilation
 
@@ -50,3 +51,16 @@
 (deftest test-compiler-resolution
   (testing "resolve nonexistent class create should return nil (assembla #262)"
     (is (nil? (resolve 'NonExistentClass.)))))
+
+(deftest test-aot-transitivity
+  (is (not *transitive-compile*))
+  (testing "Ensure transitively-compiled namespaces have corresponding
+            classfiles, converse for non-transitively-compiled namespaces"
+    (let [test-classfiles (file-seq (io/file "test-classes/clojure/test_clojure/aot"))]
+      
+      (is (some #(-> % .getName (.startsWith "transitive1")) test-classfiles))
+      (is (Class/forName "clojure.test_clojure.aot.transitive1.SomeType"))
+      
+      (is (not (some #(-> % .getName (.startsWith "nontransitive1")) test-classfiles)))
+      (is (thrown? java.lang.ClassNotFoundException
+            (Class/forName "clojure.test_clojure.aot.nontransitive.ThisClassShouldNotBeFound"))))))
-- 
1.7.1

