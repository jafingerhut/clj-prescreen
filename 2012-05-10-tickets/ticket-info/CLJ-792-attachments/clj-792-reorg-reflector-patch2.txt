From 68593a3842f9433c8033175f66f7e0233cce47ee Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 18:55:31 -0700
Subject: [PATCH 01/20] Refactor repeated code for evaling arg-exprs into separate method.

---
 src/jvm/clojure/lang/Compiler.java |   19 ++++++++++---------
 1 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index bfc8274..5cc7dc4 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1377,9 +1377,7 @@ static class InstanceMethodExpr extends MethodExpr{
 		try
 			{
 			Object targetval = target.eval();
-			Object[] argvals = new Object[args.count()];
-			for(int i = 0; i < args.count(); i++)
-				argvals[i] = ((Expr) args.nth(i)).eval();
+			Object[] argvals = argexprVals(args);
 			if(method != null)
 				{
 				LinkedList ms = new LinkedList();
@@ -1525,9 +1523,7 @@ static class StaticMethodExpr extends MethodExpr{
 	public Object eval() {
 		try
 			{
-			Object[] argvals = new Object[args.count()];
-			for(int i = 0; i < args.count(); i++)
-				argvals[i] = ((Expr) args.nth(i)).eval();
+			Object[] argvals = argexprVals(args);
 			if(method != null)
 				{
 				LinkedList ms = new LinkedList();
@@ -2367,9 +2363,7 @@ public static class NewExpr implements Expr{
 	}
 
 	public Object eval() {
-		Object[] argvals = new Object[args.count()];
-		for(int i = 0; i < args.count(); i++)
-			argvals[i] = ((Expr) args.nth(i)).eval();
+		Object[] argvals = argexprVals(args);
 		if(this.ctor != null)
 			{
 			try
@@ -2619,6 +2613,13 @@ public static class IfExpr implements Expr, MaybePrimitiveExpr{
 	}
 }
 
+private static Object[] argexprVals(IPersistentVector argexprs){
+    Object[] argvals = new Object[argexprs.count()];
+    for(int i = 0; i < argexprs.count(); i++)
+        argvals[i] = ((Expr) argexprs.nth(i)).eval();
+    return argvals;
+}
+
 static final public IPersistentMap CHAR_MAP =
 		PersistentHashMap.create('-', "_",
 //		                         '.', "_DOT_",
-- 
1.7.3.5


From 95f7ffe6de843aa2ad1a84a0ce07604cb8814696 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 18:57:19 -0700
Subject: [PATCH 02/20] Refactor Compiler.getMatchingParams to not be coupled to Exprs (in preparation to move it to Reflector)

---
 src/jvm/clojure/lang/Compiler.java |   29 +++++++++++++++++++----------
 1 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 5cc7dc4..082ac7a 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1350,7 +1350,7 @@ static class InstanceMethodExpr extends MethodExpr{
 						params.add(m.getParameterTypes());
 						rets.add(m.getReturnType());
 						}
-					methodidx = getMatchingParams(methodName, params, args, rets);
+					methodidx = getMatchingParams(methodName, params, argexprTypes(args), rets);
 					}
 				java.lang.reflect.Method m =
 						(java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
@@ -1509,7 +1509,7 @@ static class StaticMethodExpr extends MethodExpr{
 				params.add(m.getParameterTypes());
 				rets.add(m.getReturnType());
 				}
-			methodidx = getMatchingParams(methodName, params, args, rets);
+			methodidx = getMatchingParams(methodName, params, argexprTypes(args), rets);
 			}
 		method = (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
 		if(method == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
@@ -2261,7 +2261,7 @@ static public boolean subsumes(Class[] c1, Class[] c2){
 	return better;
 }
 
-static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs,
+static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
                              List<Class> rets)
 		{
 	//presumes matching lengths
@@ -2271,19 +2271,17 @@ static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, I
 	for(int i = 0; i < paramlists.size(); i++)
 		{
 		boolean match = true;
-		ISeq aseq = argexprs.seq();
 		int exact = 0;
-		for(int p = 0; match && p < argexprs.count() && aseq != null; ++p, aseq = aseq.next())
+		for(int p = 0; match && p < argTypes.length; ++p)
 			{
-			Expr arg = (Expr) aseq.first();
-			Class aclass = arg.hasJavaClass() ? arg.getJavaClass() : Object.class;
+			Class aclass = argTypes[p];
 			Class pclass = paramlists.get(i)[p];
-			if(arg.hasJavaClass() && aclass == pclass)
+			if(aclass == pclass)
 				exact++;
 			else
 				match = Reflector.paramArgTypeMatch(pclass, aclass);
 			}
-		if(exact == argexprs.count())
+		if(exact == argTypes.length)
             {
             if(!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                 matchIdx = i;
@@ -2350,7 +2348,7 @@ public static class NewExpr implements Expr{
 		int ctoridx = 0;
 		if(ctors.size() > 1)
 			{
-			ctoridx = getMatchingParams(c.getName(), params, args, rets);
+			ctoridx = getMatchingParams(c.getName(), params, argexprTypes(args), rets);
 			}
 
 		this.ctor = ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
@@ -2613,6 +2611,17 @@ public static class IfExpr implements Expr, MaybePrimitiveExpr{
 	}
 }
 
+static Class[] argexprTypes(IPersistentVector argexprs){
+    Class[] argTypes = new Class[argexprs.count()];
+    ISeq aseq = argexprs.seq();
+    for(int i = 0; i < argexprs.count() && aseq != null; i++, aseq = aseq.next())
+    {
+        Expr arg = (Expr) aseq.first();
+        argTypes[i] = arg.hasJavaClass() ? arg.getJavaClass() : Object.class;
+    }
+    return argTypes;
+}
+
 private static Object[] argexprVals(IPersistentVector argexprs){
     Object[] argvals = new Object[argexprs.count()];
     for(int i = 0; i < argexprs.count(); i++)
-- 
1.7.3.5


From 264aafbc74361405973b15a72d6840b72259457d Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 19:04:03 -0700
Subject: [PATCH 03/20] move getMatchingParams method from Compiler to Reflector

---
 src/jvm/clojure/lang/Compiler.java  |   79 +---------------------------------
 src/jvm/clojure/lang/Reflector.java |   74 ++++++++++++++++++++++++++++++++-
 2 files changed, 76 insertions(+), 77 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 082ac7a..980f128 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1350,7 +1350,7 @@ static class InstanceMethodExpr extends MethodExpr{
 						params.add(m.getParameterTypes());
 						rets.add(m.getReturnType());
 						}
-					methodidx = getMatchingParams(methodName, params, argexprTypes(args), rets);
+					methodidx = Reflector.getMatchingParams(methodName, params, argexprTypes(args), rets);
 					}
 				java.lang.reflect.Method m =
 						(java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
@@ -1509,7 +1509,7 @@ static class StaticMethodExpr extends MethodExpr{
 				params.add(m.getParameterTypes());
 				rets.add(m.getReturnType());
 				}
-			methodidx = getMatchingParams(methodName, params, argexprTypes(args), rets);
+			methodidx = Reflector.getMatchingParams(methodName, params, argexprTypes(args), rets);
 			}
 		method = (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
 		if(method == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
@@ -2242,79 +2242,6 @@ static class ThrowExpr extends UntypedExpr{
 }
 
 
-static public boolean subsumes(Class[] c1, Class[] c2){
-	//presumes matching lengths
-	Boolean better = false;
-	for(int i = 0; i < c1.length; i++)
-		{
-		if(c1[i] != c2[i])// || c2[i].isPrimitive() && c1[i] == Object.class))
-			{
-			if(!c1[i].isPrimitive() && c2[i].isPrimitive()
-			   //|| Number.class.isAssignableFrom(c1[i]) && c2[i].isPrimitive()
-			   ||
-			   c2[i].isAssignableFrom(c1[i]))
-				better = true;
-			else
-				return false;
-			}
-		}
-	return better;
-}
-
-static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
-                             List<Class> rets)
-		{
-	//presumes matching lengths
-	int matchIdx = -1;
-	boolean tied = false;
-    boolean foundExact = false;
-	for(int i = 0; i < paramlists.size(); i++)
-		{
-		boolean match = true;
-		int exact = 0;
-		for(int p = 0; match && p < argTypes.length; ++p)
-			{
-			Class aclass = argTypes[p];
-			Class pclass = paramlists.get(i)[p];
-			if(aclass == pclass)
-				exact++;
-			else
-				match = Reflector.paramArgTypeMatch(pclass, aclass);
-			}
-		if(exact == argTypes.length)
-            {
-            if(!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
-                matchIdx = i;
-            tied = false;
-            foundExact = true;
-            }
-		else if(match && !foundExact)
-			{
-			if(matchIdx == -1)
-				matchIdx = i;
-			else
-				{
-				if(subsumes(paramlists.get(i), paramlists.get(matchIdx)))
-					{
-					matchIdx = i;
-					tied = false;
-					}
-				else if(Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
-					{
-					if(rets.get(matchIdx).isAssignableFrom(rets.get(i)))
-						matchIdx = i;
-					}
-				else if(!(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
-						tied = true;
-				}
-			}
-		}
-	if(tied)
-		throw new IllegalArgumentException("More than one matching method found: " + methodName);
-
-	return matchIdx;
-}
-
 public static class NewExpr implements Expr{
 	public final IPersistentVector args;
 	public final Constructor ctor;
@@ -2348,7 +2275,7 @@ public static class NewExpr implements Expr{
 		int ctoridx = 0;
 		if(ctors.size() > 1)
 			{
-			ctoridx = getMatchingParams(c.getName(), params, argexprTypes(args), rets);
+			ctoridx = Reflector.getMatchingParams(c.getName(), params, argexprTypes(args), rets);
 			}
 
 		this.ctor = ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index e47c264..623f9db 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -66,7 +66,7 @@ static Object invokeMatchingMethod(String methodName, List methods, Object targe
 			Class[] params = m.getParameterTypes();
 			if(isCongruent(params, args))
 				{
-				if(foundm == null || Compiler.subsumes(params, foundm.getParameterTypes()))
+				if(foundm == null || subsumes(params, foundm.getParameterTypes()))
 					{
 					foundm = m;
 					boxedArgs = boxArgs(params, args);
@@ -371,6 +371,78 @@ static public Field getField(Class c, String name, boolean getStatics){
 	return null;
 }
 
+static public boolean subsumes(Class[] c1, Class[] c2){
+	//presumes matching lengths
+	Boolean better = false;
+	for(int i = 0; i < c1.length; i++)
+		{
+		if(c1[i] != c2[i])// || c2[i].isPrimitive() && c1[i] == Object.class))
+			{
+			if(!c1[i].isPrimitive() && c2[i].isPrimitive()
+			   //|| Number.class.isAssignableFrom(c1[i]) && c2[i].isPrimitive()
+			   ||
+			   c2[i].isAssignableFrom(c1[i]))
+				better = true;
+			else
+				return false;
+			}
+		}
+	return better;
+}
+
+static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
+                             List<Class> rets)
+		{
+	//presumes matching lengths
+	int matchIdx = -1;
+	boolean tied = false;
+    boolean foundExact = false;
+	for(int i = 0; i < paramlists.size(); i++)
+		{
+		boolean match = true;
+		int exact = 0;
+		for(int p = 0; match && p < argTypes.length; ++p)
+			{
+			Class aclass = argTypes[p];
+			Class pclass = paramlists.get(i)[p];
+			if(aclass == pclass)
+				exact++;
+			else
+				match = Reflector.paramArgTypeMatch(pclass, aclass);
+			}
+		if(exact == argTypes.length)
+            {
+            if(!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
+                matchIdx = i;
+            foundExact = true;
+            }
+		else if(match && !foundExact)
+			{
+			if(matchIdx == -1)
+				matchIdx = i;
+			else
+				{
+				if(subsumes(paramlists.get(i), paramlists.get(matchIdx)))
+					{
+					matchIdx = i;
+					tied = false;
+					}
+				else if(Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
+					{
+					if(rets.get(matchIdx).isAssignableFrom(rets.get(i)))
+						matchIdx = i;
+					}
+				else if(!(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
+						tied = true;
+				}
+			}
+		}
+	if(tied)
+		throw new IllegalArgumentException("More than one matching method found: " + methodName);
+
+	return matchIdx;
+}
+
 static public List getMethods(Class c, int arity, String name, boolean getStatics){
 	Method[] allmethods = c.getMethods();
 	ArrayList methods = new ArrayList();
-- 
1.7.3.5


From 3fa72b817e416f528acfc8f4f20860102401f4c8 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 19:13:52 -0700
Subject: [PATCH 04/20] Moved instance-method-finding code from Compiler to Reflector

---
 src/jvm/clojure/lang/Compiler.java  |   29 +----------------------------
 src/jvm/clojure/lang/Reflector.java |   30 ++++++++++++++++++++++++++++++
 2 files changed, 31 insertions(+), 28 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 980f128..884044f 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1333,34 +1333,7 @@ static class InstanceMethodExpr extends MethodExpr{
 		this.tag = tag;
 		if(target.hasJavaClass() && target.getJavaClass() != null)
 			{
-			List methods = Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false);
-			if(methods.isEmpty())
-				method = null;
-			//throw new IllegalArgumentException("No matching method found");
-			else
-				{
-				int methodidx = 0;
-				if(methods.size() > 1)
-					{
-					ArrayList<Class[]> params = new ArrayList();
-					ArrayList<Class> rets = new ArrayList();
-					for(int i = 0; i < methods.size(); i++)
-						{
-						java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
-						params.add(m.getParameterTypes());
-						rets.add(m.getReturnType());
-						}
-					methodidx = Reflector.getMatchingParams(methodName, params, argexprTypes(args), rets);
-					}
-				java.lang.reflect.Method m =
-						(java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
-				if(m != null && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
-					{
-					//public method of non-public class, try to find it in hierarchy
-					m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m);
-					}
-				method = m;
-				}
+			method = Reflector.getMatchingInstanceMethod(target.getJavaClass(), methodName, argexprTypes(args));
 			}
 		else
 			method = null;
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 623f9db..58308d3 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -495,6 +495,36 @@ static public List getMethods(Class c, int arity, String name, boolean getStatic
 	return methods;
 }
 
+public static Method getMatchingInstanceMethod(Class c, String methodName, Class[] argTypes){
+    List methods = getMethods(c, argTypes.length, methodName, false);
+    if(methods.isEmpty())
+        return null;
+    //throw new IllegalArgumentException("No matching method found");
+    else
+        {
+        int methodidx = 0;
+        if(methods.size() > 1)
+            {
+            ArrayList<Class[]> params = new ArrayList();
+            ArrayList<Class> rets = new ArrayList();
+            for(int i = 0; i < methods.size(); i++)
+                {
+                java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
+                params.add(m.getParameterTypes());
+                rets.add(m.getReturnType());
+                }
+            methodidx = getMatchingParams(methodName, params, argTypes, rets);
+            }
+        java.lang.reflect.Method m =
+                (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
+        if(m != null && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
+            {
+            //public method of non-public class, try to find it in hierarchy
+            m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m);
+            }
+        return m;
+        }
+}
 
 static Object boxArg(Class paramType, Object arg){
 	if(!paramType.isPrimitive())
-- 
1.7.3.5


From d12567d65aba3b065a00809bd008517b41406858 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 19:19:11 -0700
Subject: [PATCH 05/20] Moved static-method-finding code from Compiler to Reflector

---
 src/jvm/clojure/lang/Compiler.java  |   19 +------------------
 src/jvm/clojure/lang/Reflector.java |   21 +++++++++++++++++++++
 2 files changed, 22 insertions(+), 18 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 884044f..2ae143f 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1467,24 +1467,7 @@ static class StaticMethodExpr extends MethodExpr{
 		this.line = line;
 		this.tag = tag;
 
-		List methods = Reflector.getMethods(c, args.count(), methodName, true);
-		if(methods.isEmpty())
-			throw new IllegalArgumentException("No matching method: " + methodName);
-
-		int methodidx = 0;
-		if(methods.size() > 1)
-			{
-			ArrayList<Class[]> params = new ArrayList();
-			ArrayList<Class> rets = new ArrayList();
-			for(int i = 0; i < methods.size(); i++)
-				{
-				java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
-				params.add(m.getParameterTypes());
-				rets.add(m.getReturnType());
-				}
-			methodidx = Reflector.getMatchingParams(methodName, params, argexprTypes(args), rets);
-			}
-		method = (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
+		method = Reflector.getMatchingStaticMethod(c, methodName, argexprTypes(args));
 		if(method == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
 			{
 			RT.errPrintWriter()
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 58308d3..886ee87 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -526,6 +526,27 @@ public static Method getMatchingInstanceMethod(Class c, String methodName, Class
         }
 }
 
+public static Method getMatchingStaticMethod(Class c, String methodName, Class[] argTypes){
+    List methods = getMethods(c, argTypes.length, methodName, true);
+    if(methods.isEmpty())
+        throw new IllegalArgumentException("No matching method: " + methodName);
+
+    int methodidx = 0;
+    if(methods.size() > 1)
+        {
+        ArrayList<Class[]> params = new ArrayList();
+        ArrayList<Class> rets = new ArrayList();
+        for(int i = 0; i < methods.size(); i++)
+            {
+            java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
+            params.add(m.getParameterTypes());
+            rets.add(m.getReturnType());
+            }
+        methodidx = getMatchingParams(methodName, params, argTypes, rets);
+        }
+    return (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
+}
+
 static Object boxArg(Class paramType, Object arg){
 	if(!paramType.isPrimitive())
 		return paramType.cast(arg);
-- 
1.7.3.5


From a47927b2d7b192fd14655fc776ab0c396246f31e Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 19:24:31 -0700
Subject: [PATCH 06/20] Moved constructor-finding code from Compiler to Reflector

---
 src/jvm/clojure/lang/Compiler.java  |   25 +------------------------
 src/jvm/clojure/lang/Reflector.java |   27 +++++++++++++++++++++++++++
 2 files changed, 28 insertions(+), 24 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 2ae143f..9855f70 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -2211,30 +2211,7 @@ public static class NewExpr implements Expr{
 	public NewExpr(Class c, IPersistentVector args, int line) {
 		this.args = args;
 		this.c = c;
-		Constructor[] allctors = c.getConstructors();
-		ArrayList ctors = new ArrayList();
-		ArrayList<Class[]> params = new ArrayList();
-		ArrayList<Class> rets = new ArrayList();
-		for(int i = 0; i < allctors.length; i++)
-			{
-			Constructor ctor = allctors[i];
-			if(ctor.getParameterTypes().length == args.count())
-				{
-				ctors.add(ctor);
-				params.add(ctor.getParameterTypes());
-				rets.add(c);
-				}
-			}
-		if(ctors.isEmpty())
-			throw new IllegalArgumentException("No matching ctor found for " + c);
-
-		int ctoridx = 0;
-		if(ctors.size() > 1)
-			{
-			ctoridx = Reflector.getMatchingParams(c.getName(), params, argexprTypes(args), rets);
-			}
-
-		this.ctor = ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
+		ctor = Reflector.getMatchingConstructor(c, argexprTypes(args));
 		if(ctor == null && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
 			{
 			RT.errPrintWriter()
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 886ee87..34431d5 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -443,6 +443,33 @@ static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, C
 	return matchIdx;
 }
 
+public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
+    Constructor[] allctors = c.getConstructors();
+    ArrayList ctors = new ArrayList();
+    ArrayList<Class[]> params = new ArrayList();
+    ArrayList<Class> rets = new ArrayList();
+    for(int i = 0; i < allctors.length; i++)
+        {
+        Constructor ctor = allctors[i];
+        if(ctor.getParameterTypes().length == argTypes.length)
+            {
+            ctors.add(ctor);
+            params.add(ctor.getParameterTypes());
+            rets.add(c);
+            }
+        }
+    if(ctors.isEmpty())
+        throw new IllegalArgumentException("No matching ctor found for " + c);
+
+    int ctoridx = 0;
+    if(ctors.size() > 1)
+        {
+        ctoridx = getMatchingParams(c.getName(), params, argTypes, rets);
+        }
+
+    return ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
+}
+
 static public List getMethods(Class c, int arity, String name, boolean getStatics){
 	Method[] allmethods = c.getMethods();
 	ArrayList methods = new ArrayList();
-- 
1.7.3.5


From eb25c6aa39a79690942cc014f28dd81d7d95896b Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 22:35:29 -0700
Subject: [PATCH 07/20] Removing external references to low-level, arity-based Reflector.getMethods method

---
 src/jvm/clojure/lang/Compiler.java  |   13 +++++++------
 src/jvm/clojure/lang/Reflector.java |    4 ++--
 2 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 9855f70..0095f8f 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -432,7 +432,9 @@ static class DefExpr implements Expr{
 		return Var.class;
 	}
 
-	static class Parser implements IParser{
+    private static final Class[] EMPTY_TYPES = new Class[0];
+
+    static class Parser implements IParser{
 		public Expr parse(C context, Object form) {
 			//(def x) or (def x initexpr) or (def x "docstring" initexpr)
 			String docstring = null;
@@ -884,9 +886,9 @@ static public abstract class HostExpr implements Expr, MaybePrimitiveExpr{
 				{
 				Symbol sym = (Symbol) RT.third(form);
 				if(c != null)
-					maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0;
+					maybeField = Reflector.getMatchingStaticMethod(c, munge(sym.name), EMPTY_TYPES) == null;
 				else if(instance != null && instance.hasJavaClass() && instance.getJavaClass() != null)
-					maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0;
+					maybeField = Reflector.getMatchingInstanceMethod(instance.getJavaClass(), munge(sym.name), EMPTY_TYPES) == null;
 				}
 
 			if(maybeField)    //field
@@ -3171,12 +3173,11 @@ static class InvokeExpr implements Expr{
                               " (The protocol method may have been defined before and removed.)");
                     }
                     String mname = munge(mmapVal.sym.toString());
- 					List methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);
-					if(methods.size() != 1)
+                    this.onMethod = Reflector.getMatchingInstanceMethod(protocolOn, mname, argexprTypes(RT.subvec(args, 1, args.count())));
+					if(this.onMethod == null)
 						throw new IllegalArgumentException(
 								"No single method: " + mname + " of interface: " + protocolOn.getName() +
 								" found for function: " + fvar.sym + " of protocol: " + pvar.sym);
-					this.onMethod = (java.lang.reflect.Method) methods.get(0);
 					}
 				}
 			}
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 34431d5..0c39cbe 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -470,7 +470,7 @@ public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
     return ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
 }
 
-static public List getMethods(Class c, int arity, String name, boolean getStatics){
+static private List getMethods(Class c, int arity, String name, boolean getStatics){
 	Method[] allmethods = c.getMethods();
 	ArrayList methods = new ArrayList();
 	ArrayList bridgeMethods = new ArrayList();
@@ -556,7 +556,7 @@ public static Method getMatchingInstanceMethod(Class c, String methodName, Class
 public static Method getMatchingStaticMethod(Class c, String methodName, Class[] argTypes){
     List methods = getMethods(c, argTypes.length, methodName, true);
     if(methods.isEmpty())
-        throw new IllegalArgumentException("No matching method: " + methodName);
+        return null;
 
     int methodidx = 0;
     if(methods.size() > 1)
-- 
1.7.3.5


From b9c15349374c099e9671f9f8317eca8044c261e3 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 21:47:02 -0700
Subject: [PATCH 08/20] Move code around invoking a Constructor instance from Compiler into Reflector.newInstance

---
 src/jvm/clojure/lang/Compiler.java  |    9 +--------
 src/jvm/clojure/lang/Reflector.java |   11 +++++++++++
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 0095f8f..d810621 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -2226,14 +2226,7 @@ public static class NewExpr implements Expr{
 		Object[] argvals = argexprVals(args);
 		if(this.ctor != null)
 			{
-			try
-				{
-				return ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals));
-				}
-			catch(Exception e)
-				{
-				throw Util.runtimeException(e);
-				}
+			return Reflector.newInstance(this.ctor, argvals);
 			}
 		return Reflector.invokeConstructor(c, argvals);
 	}
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 0c39cbe..6ffae35 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -150,6 +150,17 @@ public static boolean isMatch(Method lhs, Method rhs) {
 		return match;
 }
 
+public static Object newInstance(Constructor ctor, Object[] args){
+    try
+        {
+        return ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), args));
+        }
+    catch(Exception e)
+        {
+        throw Util.runtimeException(e);
+        }
+}
+
 public static Object invokeConstructor(Class c, Object[] args) {
 	try
 		{
-- 
1.7.3.5


From 0bb0fd1a5121fc3a08b1be887207d2e59e617bd5 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Mon, 25 Apr 2011 22:26:25 -0700
Subject: [PATCH 09/20] Move code around invoking a Method instance from Compiler into Reflector.invokeMethod

---
 src/jvm/clojure/lang/Compiler.java  |    8 ++------
 src/jvm/clojure/lang/Reflector.java |    7 ++++++-
 2 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index d810621..68253a6 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -1355,9 +1355,7 @@ static class InstanceMethodExpr extends MethodExpr{
 			Object[] argvals = argexprVals(args);
 			if(method != null)
 				{
-				LinkedList ms = new LinkedList();
-				ms.add(method);
-				return Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals);
+				return Reflector.invokeMethod(targetval, method, argvals);
 				}
 			return Reflector.invokeInstanceMethod(targetval, methodName, argvals);
 			}
@@ -1484,9 +1482,7 @@ static class StaticMethodExpr extends MethodExpr{
 			Object[] argvals = argexprVals(args);
 			if(method != null)
 				{
-				LinkedList ms = new LinkedList();
-				ms.add(method);
-				return Reflector.invokeMatchingMethod(methodName, ms, null, argvals);
+				return Reflector.invokeMethod(c, method, argvals);
 				}
 			return Reflector.invokeStaticMethod(c, methodName, argvals);
 			}
diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 6ffae35..9c368bb 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -43,7 +43,12 @@ private static String noMethodReport(String methodName, Object target){
 	 return "No matching method found: " + methodName
 			+ (target==null?"":" for " + target.getClass());
 }
-static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
+
+public static Object invokeMethod(Object target, Method method, Object[] args){
+    return invokeMatchingMethod(method.getName(), Arrays.asList(method), target, args);
+}
+
+private static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
 		{
 	Method m = null;
 	Object[] boxedArgs = null;
-- 
1.7.3.5


From e6d91af911e30abffa1a004ad156215b145e5d68 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Tue, 26 Apr 2011 00:11:47 -0700
Subject: [PATCH 10/20] Remove unused Reflector methods

---
 src/jvm/clojure/lang/Reflector.java |   47 -----------------------------------
 1 files changed, 0 insertions(+), 47 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 9c368bb..9d64254 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -213,11 +213,6 @@ public static Object invokeConstructor(Class c, Object[] args) {
 		}
 }
 
-public static Object invokeStaticMethodVariadic(String className, String methodName, Object... args) {
-	return invokeStaticMethod(className, methodName, args);
-
-}
-
 public static Object invokeStaticMethod(String className, String methodName, Object[] args) {
 	Class c = RT.classForName(className);
 	try
@@ -334,48 +329,6 @@ public static Object invokeNoArgInstanceMember(Object target, String name) {
 		return getInstanceField(target, name);
 }
 
-public static Object invokeInstanceMember(Object target, String name) {
-	//check for field first
-	Class c = target.getClass();
-	Field f = getField(c, name, false);
-	if(f != null)  //field get
-		{
-		try
-			{
-			return prepRet(f.getType(), f.get(target));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		}
-	return invokeInstanceMethod(target, name, RT.EMPTY_ARRAY);
-}
-
-public static Object invokeInstanceMember(String name, Object target, Object arg1) {
-	//check for field first
-	Class c = target.getClass();
-	Field f = getField(c, name, false);
-	if(f != null)  //field set
-		{
-		try
-			{
-			f.set(target, boxArg(f.getType(), arg1));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		return arg1;
-		}
-	return invokeInstanceMethod(target, name, new Object[]{arg1});
-}
-
-public static Object invokeInstanceMember(String name, Object target, Object... args) {
-	return invokeInstanceMethod(target, name, args);
-}
-
-
 static public Field getField(Class c, String name, boolean getStatics){
 	Field[] allfields = c.getFields();
 	for(int i = 0; i < allfields.length; i++)
-- 
1.7.3.5


From a48ea59b3337c35dead0fd9ac1dc75b9221751d8 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Tue, 26 Apr 2011 00:12:23 -0700
Subject: [PATCH 11/20] Privatize reflector helper methods

---
 src/jvm/clojure/lang/Reflector.java |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 9d64254..bec6175 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -107,7 +107,7 @@ private static Object invokeMatchingMethod(String methodName, List methods, Obje
 
 }
 
-public static Method getAsMethodOfPublicBase(Class c, Method m){
+private static Method getAsMethodOfPublicBase(Class c, Method m){
 	for(Class iface : c.getInterfaces())
 		{
 		for(Method im : iface.getMethods())
@@ -340,7 +340,7 @@ static public Field getField(Class c, String name, boolean getStatics){
 	return null;
 }
 
-static public boolean subsumes(Class[] c1, Class[] c2){
+private static boolean subsumes(Class[] c1, Class[] c2){
 	//presumes matching lengths
 	Boolean better = false;
 	for(int i = 0; i < c1.length; i++)
@@ -359,7 +359,7 @@ static public boolean subsumes(Class[] c1, Class[] c2){
 	return better;
 }
 
-static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
+private static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
                              List<Class> rets)
 		{
 	//presumes matching lengths
@@ -543,7 +543,7 @@ public static Method getMatchingStaticMethod(Class c, String methodName, Class[]
     return (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
 }
 
-static Object boxArg(Class paramType, Object arg){
+private static Object boxArg(Class paramType, Object arg){
 	if(!paramType.isPrimitive())
 		return paramType.cast(arg);
 	else if(paramType == boolean.class)
@@ -570,7 +570,7 @@ static Object boxArg(Class paramType, Object arg){
 	                                   ", given: " + arg.getClass().getName());
 }
 
-static Object[] boxArgs(Class[] params, Object[] args){
+private static Object[] boxArgs(Class[] params, Object[] args){
 	if(params.length == 0)
 		return null;
 	Object[] ret = new Object[params.length];
@@ -583,7 +583,7 @@ static Object[] boxArgs(Class[] params, Object[] args){
 	return ret;
 }
 
-static public boolean paramArgTypeMatch(Class paramType, Class argType){
+private static boolean paramArgTypeMatch(Class paramType, Class argType){
 	if(argType == null)
 		return !paramType.isPrimitive();
 	if(paramType == argType || paramType.isAssignableFrom(argType))
@@ -616,7 +616,7 @@ static public boolean paramArgTypeMatch(Class paramType, Class argType){
 	return false;
 }
 
-static boolean isCongruent(Class[] params, Object[] args){
+private static boolean isCongruent(Class[] params, Object[] args){
 	boolean ret = false;
 	if(args == null)
 		return params.length == 0;
-- 
1.7.3.5


From 64bd376a18fc2e55ae85355545100f803f9b0da0 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 13:07:48 -0700
Subject: [PATCH 12/20] Reflector DRY clean-up: .invokeConstructor and .getMatchingConstructor now both use the same code to find a Constructor instance, and .invokeConstructor uses .newInstance to create a new instance from a Constructor.

---
 src/jvm/clojure/lang/Reflector.java |  104 ++++++++++++++++++----------------
 1 files changed, 55 insertions(+), 49 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index bec6175..802be3b 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -17,11 +17,48 @@ import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 
 public class Reflector{
 
+private static Class getClass(Object o){
+    return o == null ? null : o.getClass();
+}
+
+private static String getName(Class c){
+    return c == null ? "null" : c.getName();
+}
+
+private static String toString(Class[] cs){
+    StringBuffer sb = new StringBuffer(cs[0].getName());
+    for (int i = 1; i < cs.length; i++)
+        {
+        sb.append(",");
+        sb.append(getName(cs[i]));
+        }
+    return sb.toString();
+}
+
+private static Class[] argTypes(Object[] args){
+    Class[] cs = new Class[args.length];
+    for (int i = 0; i < args.length; i++)
+        cs[i] = getClass(args[i]);
+    return cs;
+}
+
+/* Enums to mitigate bugs from multiple boolean flags
+ */
+
+private enum Invoking{
+    T(true), F(false);
+    public final boolean b;
+    private Invoking(boolean b){
+        this.b = b;
+    }
+}
+
 public static Object invokeInstanceMethod(Object target, String methodName, Object[] args) {
 	try
 		{
@@ -167,50 +204,9 @@ public static Object newInstance(Constructor ctor, Object[] args){
 }
 
 public static Object invokeConstructor(Class c, Object[] args) {
-	try
-		{
-		Constructor[] allctors = c.getConstructors();
-		ArrayList ctors = new ArrayList();
-		for(int i = 0; i < allctors.length; i++)
-			{
-			Constructor ctor = allctors[i];
-			if(ctor.getParameterTypes().length == args.length)
-				ctors.add(ctor);
-			}
-		if(ctors.isEmpty())
-			{
-			throw new IllegalArgumentException("No matching ctor found"
-				+ " for " + c);
-			}
-		else if(ctors.size() == 1)
-			{
-			Constructor ctor = (Constructor) ctors.get(0);
-			return ctor.newInstance(boxArgs(ctor.getParameterTypes(), args));
-			}
-		else //overloaded w/same arity
-			{
-			for(Iterator iterator = ctors.iterator(); iterator.hasNext();)
-				{
-				Constructor ctor = (Constructor) iterator.next();
-				Class[] params = ctor.getParameterTypes();
-				if(isCongruent(params, args))
-					{
-					Object[] boxedArgs = boxArgs(params, args);
-					return ctor.newInstance(boxedArgs);
-					}
-				}
-			throw new IllegalArgumentException("No matching ctor found"
-				+ " for " + c);
-			}
-		}
-	catch(Exception e)
-		{
-		if(e.getCause() instanceof Exception)
-			throw Util.runtimeException(e.getCause());
-		else if(e.getCause() instanceof Error)
-			throw (Error) e.getCause();
-		throw Util.runtimeException(e);
-		}
+    Class[] argTypes = argTypes(args);
+    Constructor ctor = getMatchingConstructor(c, argTypes, Invoking.T);
+    return newInstance(ctor, args);
 }
 
 public static Object invokeStaticMethod(String className, String methodName, Object[] args) {
@@ -412,7 +408,7 @@ private static int getMatchingParams(String methodName, ArrayList<Class[]> param
 	return matchIdx;
 }
 
-public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
+private static Constructor getMatchingConstructor(Class c, Class[] argTypes, Invoking invoking){
     Constructor[] allctors = c.getConstructors();
     ArrayList ctors = new ArrayList();
     ArrayList<Class[]> params = new ArrayList();
@@ -427,16 +423,26 @@ public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
             rets.add(c);
             }
         }
-    if(ctors.isEmpty())
-        throw new IllegalArgumentException("No matching ctor found for " + c);
 
-    int ctoridx = 0;
+    int ctoridx = -1;
+    if (ctors.size() == 1)
+        {
+        ctoridx = 0;
+        }
     if(ctors.size() > 1)
         {
         ctoridx = getMatchingParams(c.getName(), params, argTypes, rets);
         }
 
-    return ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
+    Constructor ctor = ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
+
+    if (ctor == null && invoking.b)
+        throw new IllegalArgumentException("No matching constructor found in "+c.getName() + " for argtypes: " + toString(argTypes));
+    return ctor;
+}
+
+public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
+    return getMatchingConstructor(c, argTypes, Invoking.F);
 }
 
 static private List getMethods(Class c, int arity, String name, boolean getStatics){
-- 
1.7.3.5


From 012e0f6745818d0eefa1ce04f81c7131bca27410 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 14:16:30 -0700
Subject: [PATCH 13/20] Reflector DRY clean-up: .getMatchingStaticMethod and .getMatchingInstanceMethod now both use the same code to find a Method instance.

---
 src/jvm/clojure/lang/Reflector.java |   34 ++++++++++++++--------------------
 1 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 802be3b..bb73146 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -58,6 +58,13 @@ private enum Invoking{
         this.b = b;
     }
 }
+private enum Statics{
+    T(true), F(false);
+    public final boolean b;
+    private Statics(boolean b){
+        this.b = b;
+    }
+}
 
 public static Object invokeInstanceMethod(Object target, String methodName, Object[] args) {
 	try
@@ -497,8 +504,8 @@ static private List getMethods(Class c, int arity, String name, boolean getStati
 	return methods;
 }
 
-public static Method getMatchingInstanceMethod(Class c, String methodName, Class[] argTypes){
-    List methods = getMethods(c, argTypes.length, methodName, false);
+private static Method getMatchingMethod(Class c, String methodName, Class[] argTypes, Statics statics){
+    List methods = getMethods(c, argTypes.length, methodName, statics.b);
     if(methods.isEmpty())
         return null;
     //throw new IllegalArgumentException("No matching method found");
@@ -528,25 +535,12 @@ public static Method getMatchingInstanceMethod(Class c, String methodName, Class
         }
 }
 
-public static Method getMatchingStaticMethod(Class c, String methodName, Class[] argTypes){
-    List methods = getMethods(c, argTypes.length, methodName, true);
-    if(methods.isEmpty())
-        return null;
+public static Method getMatchingInstanceMethod(Class c, String methodName, Class[] argTypes){
+    return getMatchingMethod(c, methodName, argTypes, Statics.F);
+}
 
-    int methodidx = 0;
-    if(methods.size() > 1)
-        {
-        ArrayList<Class[]> params = new ArrayList();
-        ArrayList<Class> rets = new ArrayList();
-        for(int i = 0; i < methods.size(); i++)
-            {
-            java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
-            params.add(m.getParameterTypes());
-            rets.add(m.getReturnType());
-            }
-        methodidx = getMatchingParams(methodName, params, argTypes, rets);
-        }
-    return (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
+public static Method getMatchingStaticMethod(Class c, String methodName, Class[] argTypes){
+    return getMatchingMethod(c, methodName, argTypes, Statics.T);
 }
 
 private static Object boxArg(Class paramType, Object arg){
-- 
1.7.3.5


From 94292c855d7f945942ac436336e5bfbfab2e78f2 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 14:20:39 -0700
Subject: [PATCH 14/20] Reflector DRY clean-up: invert relationship between .invokeMatchingMethod and .invokeMethod

---
 src/jvm/clojure/lang/Reflector.java |   37 ++++++++++++++++++++++------------
 1 files changed, 24 insertions(+), 13 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index bb73146..3234142 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -14,6 +14,7 @@ package clojure.lang;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
@@ -89,7 +90,21 @@ private static String noMethodReport(String methodName, Object target){
 }
 
 public static Object invokeMethod(Object target, Method method, Object[] args){
-    return invokeMatchingMethod(method.getName(), Arrays.asList(method), target, args);
+    try
+        {
+        return prepRet(method.getReturnType(), method.invoke(target, boxArgs(method.getParameterTypes(), args)));
+        }
+    catch(InvocationTargetException e)
+        {
+        if (e.getCause() instanceof RuntimeException)
+            throw (RuntimeException)e.getCause(); // often this is a ClassCastException
+        else
+            throw Util.runtimeException(e);
+        }
+    catch(Exception e)
+        {
+        throw Util.runtimeException(e);
+        }
 }
 
 private static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
@@ -136,19 +151,8 @@ private static Object invokeMatchingMethod(String methodName, List methods, Obje
 			throw new IllegalArgumentException("Can't call public method of non-public class: " +
 			                                    oldm.toString());
 		}
-	try
-		{
-		return prepRet(m.getReturnType(), m.invoke(target, boxedArgs));
-		}
-	catch(Exception e)
-		{
-		if(e.getCause() instanceof Exception)
-			throw Util.runtimeException(e.getCause());
-		else if(e.getCause() instanceof Error)
-			throw (Error) e.getCause();
-		throw Util.runtimeException(e);
-		}
 
+	return invokeMethod(target, m, args);
 }
 
 private static Method getAsMethodOfPublicBase(Class c, Method m){
@@ -204,6 +208,13 @@ public static Object newInstance(Constructor ctor, Object[] args){
         {
         return ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), args));
         }
+    catch(InvocationTargetException e)
+        {
+        if (e.getCause() instanceof RuntimeException)
+            throw (RuntimeException)e.getCause(); // often this is a ClassCastException
+        else
+            throw Util.runtimeException(e);
+        }
     catch(Exception e)
         {
         throw Util.runtimeException(e);
-- 
1.7.3.5


From 097fa9e19290f5ca37859b35b7f097346ea4613d Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 14:42:22 -0700
Subject: [PATCH 15/20] Reflector DRY clean-up: .invokeStaticMethod and .invokeInstanceMethod now both use the same code to find a Method instance as getMatchingStaticMethod and .getMatchingInstanceMethod

---
 src/jvm/clojure/lang/Reflector.java |   84 +++++++----------------------------
 1 files changed, 16 insertions(+), 68 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 3234142..ba275ed 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -68,20 +68,7 @@ private enum Statics{
 }
 
 public static Object invokeInstanceMethod(Object target, String methodName, Object[] args) {
-	try
-		{
-		Class c = target.getClass();
-		List methods = getMethods(c, args.length, methodName, false);
-		return invokeMatchingMethod(methodName, methods, target, args);
-		}
-	catch(Exception e)
-		{
-		if(e.getCause() instanceof Exception)
-			throw Util.runtimeException(e.getCause());
-		else if(e.getCause() instanceof Error)
-			throw (Error) e.getCause();
-		throw Util.runtimeException(e);
-		}
+    return invokeMatchingMethod(target.getClass(), methodName, target, args, Statics.F);
 }
 
 private static String noMethodReport(String methodName, Object target){
@@ -107,52 +94,10 @@ public static Object invokeMethod(Object target, Method method, Object[] args){
         }
 }
 
-private static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
-		{
-	Method m = null;
-	Object[] boxedArgs = null;
-	if(methods.isEmpty())
-		{
-		throw new IllegalArgumentException(noMethodReport(methodName,target));
-		}
-	else if(methods.size() == 1)
-		{
-		m = (Method) methods.get(0);
-		boxedArgs = boxArgs(m.getParameterTypes(), args);
-		}
-	else //overloaded w/same arity
-		{
-		Method foundm = null;
-		for(Iterator i = methods.iterator(); i.hasNext();)
-			{
-			m = (Method) i.next();
-
-			Class[] params = m.getParameterTypes();
-			if(isCongruent(params, args))
-				{
-				if(foundm == null || subsumes(params, foundm.getParameterTypes()))
-					{
-					foundm = m;
-					boxedArgs = boxArgs(params, args);
-					}
-				}
-			}
-		m = foundm;
-		}
-	if(m == null)
-		throw new IllegalArgumentException(noMethodReport(methodName,target));
-
-	if(!Modifier.isPublic(m.getDeclaringClass().getModifiers()))
-		{
-		//public method of non-public class, try to find it in hierarchy
-		Method oldm = m;
-		m = getAsMethodOfPublicBase(m.getDeclaringClass(), m);
-		if(m == null)
-			throw new IllegalArgumentException("Can't call public method of non-public class: " +
-			                                    oldm.toString());
-		}
-
-	return invokeMethod(target, m, args);
+private static Object invokeMatchingMethod(Class c, String methodName, Object target, Object[] args, Statics statics){
+    Class[] argTypes = argTypes(args);
+    Method method = getMatchingMethod(c, methodName, argTypes, statics, Invoking.T);
+	return invokeMethod(target, method, args);
 }
 
 private static Method getAsMethodOfPublicBase(Class c, Method m){
@@ -246,8 +191,7 @@ public static Object invokeStaticMethod(String className, String methodName, Obj
 public static Object invokeStaticMethod(Class c, String methodName, Object[] args) {
 	if(methodName.equals("new"))
 		return invokeConstructor(c, args);
-	List methods = getMethods(c, args.length, methodName, true);
-	return invokeMatchingMethod(methodName, methods, null, args);
+	return invokeMatchingMethod(c, methodName, c, args, Statics.T);
 }
 
 public static Object getStaticField(String className, String fieldName) {
@@ -334,11 +278,13 @@ public static Object setInstanceField(Object target, String fieldName, Object va
 		+ " for " + target.getClass());
 }
 
+private static final Class[] EMPTY_TYPES = new Class[0];
+
 public static Object invokeNoArgInstanceMember(Object target, String name) {
 	//favor method over field
-	List meths = getMethods(target.getClass(), 0, name, false);
-	if(meths.size() > 0)
-		return invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY);
+	Method m = getMatchingInstanceMethod(target.getClass(), name, EMPTY_TYPES);
+	if(m != null)
+		return invokeMethod(target, m, EMPTY_TYPES);
 	else
 		return getInstanceField(target, name);
 }
@@ -515,7 +461,7 @@ static private List getMethods(Class c, int arity, String name, boolean getStati
 	return methods;
 }
 
-private static Method getMatchingMethod(Class c, String methodName, Class[] argTypes, Statics statics){
+private static Method getMatchingMethod(Class c, String methodName, Class[] argTypes, Statics statics, Invoking invoking){
     List methods = getMethods(c, argTypes.length, methodName, statics.b);
     if(methods.isEmpty())
         return null;
@@ -542,16 +488,18 @@ private static Method getMatchingMethod(Class c, String methodName, Class[] argT
             //public method of non-public class, try to find it in hierarchy
             m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m);
             }
+        if (m == null && invoking.b)
+            throw new IllegalArgumentException("No matching "+methodName+" method found in "+c.getName() + " for argtypes: " + toString(argTypes));
         return m;
         }
 }
 
 public static Method getMatchingInstanceMethod(Class c, String methodName, Class[] argTypes){
-    return getMatchingMethod(c, methodName, argTypes, Statics.F);
+    return getMatchingMethod(c, methodName, argTypes, Statics.F, Invoking.F);
 }
 
 public static Method getMatchingStaticMethod(Class c, String methodName, Class[] argTypes){
-    return getMatchingMethod(c, methodName, argTypes, Statics.T);
+    return getMatchingMethod(c, methodName, argTypes, Statics.T, Invoking.F);
 }
 
 private static Object boxArg(Class paramType, Object arg){
-- 
1.7.3.5


From dc4fdc489596ebdccf2cf6f615f639c51bed36a5 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 15:58:47 -0700
Subject: [PATCH 16/20] Reflector DRY clean-up: Field-related methods now all use the same code to find Fields and get/set their values.

---
 src/jvm/clojure/lang/Reflector.java |  114 +++++++++++++---------------------
 1 files changed, 44 insertions(+), 70 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index ba275ed..0414e54 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -194,28 +194,38 @@ public static Object invokeStaticMethod(Class c, String methodName, Object[] arg
 	return invokeMatchingMethod(c, methodName, c, args, Statics.T);
 }
 
+private static Object getFieldValue(Class c, String fieldName, Object target, Statics statics){
+    Field f = getField(c, fieldName, statics, Invoking.T);
+    try
+        {
+        return prepRet(f.getType(), f.get(target));
+        }
+    catch(Exception e)
+        {
+        throw Util.runtimeException(e);
+        }
+}
+
+private static Object setFieldValue(Class c, String fieldName, Object target, Object val, Statics statics){
+    Field f = getField(c, fieldName, statics, Invoking.T);
+    try
+        {
+        f.set(target, boxArg(f.getType(), val));
+        return val;
+        }
+    catch(Exception e)
+        {
+        throw Util.runtimeException(e);
+        }
+}
+
 public static Object getStaticField(String className, String fieldName) {
 	Class c = RT.classForName(className);
 	return getStaticField(c, fieldName);
 }
 
 public static Object getStaticField(Class c, String fieldName) {
-//	if(fieldName.equals("class"))
-//		return c;
-	Field f = getField(c, fieldName, true);
-	if(f != null)
-		{
-		try
-			{
-			return prepRet(f.getType(), f.get(null));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		}
-	throw new IllegalArgumentException("No matching field found: " + fieldName
-		+ " for " + c);
+    return getFieldValue(c, fieldName, c, Statics.T);
 }
 
 public static Object setStaticField(String className, String fieldName, Object val) {
@@ -224,58 +234,15 @@ public static Object setStaticField(String className, String fieldName, Object v
 }
 
 public static Object setStaticField(Class c, String fieldName, Object val) {
-	Field f = getField(c, fieldName, true);
-	if(f != null)
-		{
-		try
-			{
-			f.set(null, boxArg(f.getType(), val));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		return val;
-		}
-	throw new IllegalArgumentException("No matching field found: " + fieldName
-		+ " for " + c);
+	return setFieldValue(c, fieldName, c, val, Statics.T);
 }
 
 public static Object getInstanceField(Object target, String fieldName) {
-	Class c = target.getClass();
-	Field f = getField(c, fieldName, false);
-	if(f != null)
-		{
-		try
-			{
-			return prepRet(f.getType(), f.get(target));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		}
-	throw new IllegalArgumentException("No matching field found: " + fieldName
-		+ " for " + target.getClass());
+    return getFieldValue(target.getClass(), fieldName, target, Statics.F);
 }
 
 public static Object setInstanceField(Object target, String fieldName, Object val) {
-	Class c = target.getClass();
-	Field f = getField(c, fieldName, false);
-	if(f != null)
-		{
-		try
-			{
-			f.set(target, boxArg(f.getType(), val));
-			}
-		catch(IllegalAccessException e)
-			{
-			throw Util.runtimeException(e);
-			}
-		return val;
-		}
-	throw new IllegalArgumentException("No matching field found: " + fieldName
-		+ " for " + target.getClass());
+    return setFieldValue(target.getClass(), fieldName, target, val, Statics.F);
 }
 
 private static final Class[] EMPTY_TYPES = new Class[0];
@@ -289,15 +256,22 @@ public static Object invokeNoArgInstanceMember(Object target, String name) {
 		return getInstanceField(target, name);
 }
 
+private static Field getField(Class c, String fieldName, Statics statics, Invoking invoking){
+    for(Field f : c.getFields())
+        {
+        if(fieldName.equals(f.getName())
+           && Modifier.isStatic(f.getModifiers()) == statics.b)
+            return f;
+        }
+
+    if (invoking.b)
+        throw new IllegalArgumentException("No "+fieldName+" field found in "+c.getName());
+
+    return null;
+}
+
 static public Field getField(Class c, String name, boolean getStatics){
-	Field[] allfields = c.getFields();
-	for(int i = 0; i < allfields.length; i++)
-		{
-		if(name.equals(allfields[i].getName())
-		   && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
-			return allfields[i];
-		}
-	return null;
+	return getField(c, name, getStatics ? Statics.T : Statics.F, Invoking.F);
 }
 
 private static boolean subsumes(Class[] c1, Class[] c2){
-- 
1.7.3.5


From c8ae8b56ea148e942971d0ccdcf46d2df46f5473 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 16:47:24 -0700
Subject: [PATCH 17/20] Reflector DRY clean-up: combine access checks

---
 src/jvm/clojure/lang/Reflector.java |   64 ++++++++++++++++++++---------------
 1 files changed, 37 insertions(+), 27 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 0414e54..6669ef1 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -100,28 +100,41 @@ private static Object invokeMatchingMethod(Class c, String methodName, Object ta
 	return invokeMethod(target, method, args);
 }
 
-private static Method getAsMethodOfPublicBase(Class c, Method m){
-	for(Class iface : c.getInterfaces())
-		{
-		for(Method im : iface.getMethods())
-			{
-			if(isMatch(im, m))
-				{
-				return im;
-				}
-			}
-		}
-	Class sc = c.getSuperclass();
-	if(sc == null)
-		return null;
-	for(Method scm : sc.getMethods())
-		{
-		if(isMatch(scm, m))
-			{
-			return scm;
-			}
-		}
-	return getAsMethodOfPublicBase(sc, m);
+private static Method ensureMethodOfPublicBase(Class<?> c, Method m){
+    if (Modifier.isPublic(m.getDeclaringClass().getModifiers()))
+        return m;
+    else
+        {
+        for(Class<?> iface : c.getInterfaces())
+            {
+            for(Method im : iface.getMethods())
+                {
+                if(im.getName().equals(m.getName())
+                   && Arrays.equals(m.getParameterTypes(), im.getParameterTypes()))
+                    {
+                    return im;
+                    }
+                }
+            }
+        Class<?> sc = c.getSuperclass();
+        if(sc == null)
+            return null;
+        for(Method scm : sc.getMethods())
+            {
+            if(scm.getName().equals(m.getName())
+               && Arrays.equals(m.getParameterTypes(), scm.getParameterTypes())
+               && Modifier.isPublic(scm.getDeclaringClass().getModifiers()))
+                {
+                return scm;
+                }
+            }
+        Method n = ensureMethodOfPublicBase(sc, m); // look in parent
+        if (n == null)
+            throw new IllegalArgumentException("Can't call public method of non-public class: " +
+                    m.toString());
+        else
+            return n;
+        }
 }
 
 public static boolean isMatch(Method lhs, Method rhs) {
@@ -457,11 +470,8 @@ private static Method getMatchingMethod(Class c, String methodName, Class[] argT
             }
         java.lang.reflect.Method m =
                 (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
-        if(m != null && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
-            {
-            //public method of non-public class, try to find it in hierarchy
-            m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m);
-            }
+        if(m != null)
+            m = ensureMethodOfPublicBase(c, m);
         if (m == null && invoking.b)
             throw new IllegalArgumentException("No matching "+methodName+" method found in "+c.getName() + " for argtypes: " + toString(argTypes));
         return m;
-- 
1.7.3.5


From 5baa2f17782db89f247ff61b75f489d1cff22b52 Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 16:55:39 -0700
Subject: [PATCH 18/20] Reflector DRY clean-up: .getMatchingMethod and .getMatchingConstructor now use the same code to find member instances.

---
 src/jvm/clojure/lang/Reflector.java |  115 ++++++++++++++++++++---------------
 1 files changed, 65 insertions(+), 50 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index 6669ef1..dd126e1 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -49,6 +49,24 @@ private static Class[] argTypes(Object[] args){
     return cs;
 }
 
+/*
+ * Functions to allow common code to work with both Method and Constructor instances
+ */
+
+private static Class[] getParameterTypes(Object member){
+    if (member instanceof Method)
+        return ((Method)member).getParameterTypes();
+    else
+        return ((Constructor)member).getParameterTypes();
+}
+
+private static Class getReturnType(Object member){
+    if (member instanceof Method)
+        return ((Method)member).getReturnType();
+    else
+        return ((Constructor)member).getDeclaringClass();
+}
+
 /* Enums to mitigate bugs from multiple boolean flags
  */
 
@@ -306,7 +324,7 @@ private static boolean subsumes(Class[] c1, Class[] c2){
 	return better;
 }
 
-private static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, Class[] argTypes,
+private static <T extends Object> int getMatchingParams(T member, ArrayList<Class[]> paramlists, Class[] argTypes,
                              List<Class> rets)
 		{
 	//presumes matching lengths
@@ -354,38 +372,56 @@ private static int getMatchingParams(String methodName, ArrayList<Class[]> param
 			}
 		}
 	if(tied)
-		throw new IllegalArgumentException("More than one matching method found: " + methodName);
+	    {
+        if (member instanceof Method)
+            {
+            Method m = ((Method)member);
+            Class<?> c = m.getDeclaringClass();
+            throw new IllegalArgumentException("Found multiple "+m.getName()+" methods in "+c.getName()+" for argtypes: "+toString(argTypes));
+            }
+        else
+            {
+            Constructor<?> ctor = ((Constructor<?>)member);
+            Class<?> c = ctor.getDeclaringClass();
+            throw new IllegalArgumentException("Found multiple constructors in "+c.getName()+" for argtypes: "+toString(argTypes));
+            }
+	    }
 
 	return matchIdx;
 }
 
-private static Constructor getMatchingConstructor(Class c, Class[] argTypes, Invoking invoking){
-    Constructor[] allctors = c.getConstructors();
-    ArrayList ctors = new ArrayList();
+private static <T extends Object> T getMatchingMember(List<T> members, Class<?>[] argTypes, Invoking invoking){
+    ArrayList<T> matches = new ArrayList();
     ArrayList<Class[]> params = new ArrayList();
     ArrayList<Class> rets = new ArrayList();
-    for(int i = 0; i < allctors.length; i++)
+    for(T member : members)
         {
-        Constructor ctor = allctors[i];
-        if(ctor.getParameterTypes().length == argTypes.length)
+        if(getParameterTypes(member).length == argTypes.length)
             {
-            ctors.add(ctor);
-            params.add(ctor.getParameterTypes());
-            rets.add(c);
+            matches.add(member);
+            params.add(getParameterTypes(member));
+            rets.add(getReturnType(member));
             }
         }
 
-    int ctoridx = -1;
-    if (ctors.size() == 1)
+    int matchidx = -1;
+    if (matches.size() == 1)
         {
-        ctoridx = 0;
+        matchidx = 0;
         }
-    if(ctors.size() > 1)
+    if(matches.size() > 1)
         {
-        ctoridx = getMatchingParams(c.getName(), params, argTypes, rets);
+        matchidx = getMatchingParams(matches.get(0), params, argTypes, rets);
         }
 
-    Constructor ctor = ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
+    T match = matchidx >= 0 ? matches.get(matchidx) : null;
+
+    return match;
+}
+
+private static Constructor getMatchingConstructor(Class c, Class[] argTypes, Invoking invoking){
+    List<Constructor> ctors = Arrays.asList(c.getConstructors());
+    Constructor ctor = getMatchingMember(ctors, argTypes, invoking);
 
     if (ctor == null && invoking.b)
         throw new IllegalArgumentException("No matching constructor found in "+c.getName() + " for argtypes: " + toString(argTypes));
@@ -396,7 +432,7 @@ public static Constructor getMatchingConstructor(Class c, Class[] argTypes){
     return getMatchingConstructor(c, argTypes, Invoking.F);
 }
 
-static private List getMethods(Class c, int arity, String name, boolean getStatics){
+private static List<Method> getMethodsForName(Class c, String name, Statics statics){
 	Method[] allmethods = c.getMethods();
 	ArrayList methods = new ArrayList();
 	ArrayList bridgeMethods = new ArrayList();
@@ -404,8 +440,7 @@ static private List getMethods(Class c, int arity, String name, boolean getStati
 		{
 		Method method = allmethods[i];
 		if(name.equals(method.getName())
-		   && Modifier.isStatic(method.getModifiers()) == getStatics
-		   && method.getParameterTypes().length == arity)
+		   && Modifier.isStatic(method.getModifiers()) == statics.b)
 			{
 			try
 				{
@@ -432,14 +467,13 @@ static private List getMethods(Class c, int arity, String name, boolean getStati
 	if(methods.isEmpty())
 		methods.addAll(bridgeMethods);
 	
-	if(!getStatics && c.isInterface())
+	if(!statics.b && c.isInterface())
 		{
 		allmethods = Object.class.getMethods();
 		for(int i = 0; i < allmethods.length; i++)
 			{
 			if(name.equals(allmethods[i].getName())
-			   && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics
-			   && allmethods[i].getParameterTypes().length == arity)
+			   && Modifier.isStatic(allmethods[i].getModifiers()) == statics.b)
 				{
 				methods.add(allmethods[i]);
 				}
@@ -449,33 +483,14 @@ static private List getMethods(Class c, int arity, String name, boolean getStati
 }
 
 private static Method getMatchingMethod(Class c, String methodName, Class[] argTypes, Statics statics, Invoking invoking){
-    List methods = getMethods(c, argTypes.length, methodName, statics.b);
-    if(methods.isEmpty())
-        return null;
-    //throw new IllegalArgumentException("No matching method found");
-    else
-        {
-        int methodidx = 0;
-        if(methods.size() > 1)
-            {
-            ArrayList<Class[]> params = new ArrayList();
-            ArrayList<Class> rets = new ArrayList();
-            for(int i = 0; i < methods.size(); i++)
-                {
-                java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i);
-                params.add(m.getParameterTypes());
-                rets.add(m.getReturnType());
-                }
-            methodidx = getMatchingParams(methodName, params, argTypes, rets);
-            }
-        java.lang.reflect.Method m =
-                (java.lang.reflect.Method) (methodidx >= 0 ? methods.get(methodidx) : null);
-        if(m != null)
-            m = ensureMethodOfPublicBase(c, m);
-        if (m == null && invoking.b)
-            throw new IllegalArgumentException("No matching "+methodName+" method found in "+c.getName() + " for argtypes: " + toString(argTypes));
-        return m;
-        }
+    List<Method> methods = getMethodsForName(c, methodName, statics);
+    Method m = getMatchingMember(methods, argTypes, invoking);
+
+    if(m != null)
+        m = ensureMethodOfPublicBase(c, m);
+    if (m == null && invoking.b)
+        throw new IllegalArgumentException("No matching "+methodName+" method found in "+c.getName() + " for argtypes: " + toString(argTypes));
+    return m;
 }
 
 public static Method getMatchingInstanceMethod(Class c, String methodName, Class[] argTypes){
-- 
1.7.3.5


From e8199eeb89f44e08110d520c820fd2ce5bcf0eee Mon Sep 17 00:00:00 2001
From: Alexander Taggart <alex.taggart@expojure.com>
Date: Wed, 27 Apr 2011 17:01:35 -0700
Subject: [PATCH 19/20] Remove cruft from Reflector.

---
 src/jvm/clojure/lang/Reflector.java |   50 +++--------------------------------
 1 files changed, 4 insertions(+), 46 deletions(-)

diff --git a/src/jvm/clojure/lang/Reflector.java b/src/jvm/clojure/lang/Reflector.java
index dd126e1..be93340 100644
--- a/src/jvm/clojure/lang/Reflector.java
+++ b/src/jvm/clojure/lang/Reflector.java
@@ -19,7 +19,6 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.List;
 
 public class Reflector{
@@ -33,7 +32,7 @@ private static String getName(Class c){
 }
 
 private static String toString(Class[] cs){
-    StringBuffer sb = new StringBuffer(cs[0].getName());
+    StringBuffer sb = new StringBuffer(getName(cs[0]));
     for (int i = 1; i < cs.length; i++)
         {
         sb.append(",");
@@ -89,11 +88,6 @@ public static Object invokeInstanceMethod(Object target, String methodName, Obje
     return invokeMatchingMethod(target.getClass(), methodName, target, args, Statics.F);
 }
 
-private static String noMethodReport(String methodName, Object target){
-	 return "No matching method found: " + methodName
-			+ (target==null?"":" for " + target.getClass());
-}
-
 public static Object invokeMethod(Object target, Method method, Object[] args){
     try
         {
@@ -182,7 +176,7 @@ public static boolean isMatch(Method lhs, Method rhs) {
 public static Object newInstance(Constructor ctor, Object[] args){
     try
         {
-        return ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), args));
+        return ctor.newInstance(boxArgs(ctor.getParameterTypes(), args));
         }
     catch(InvocationTargetException e)
         {
@@ -205,18 +199,7 @@ public static Object invokeConstructor(Class c, Object[] args) {
 
 public static Object invokeStaticMethod(String className, String methodName, Object[] args) {
 	Class c = RT.classForName(className);
-	try
-		{
-		return invokeStaticMethod(c, methodName, args);
-		}
-	catch(Exception e)
-		{
-		if(e.getCause() instanceof Exception)
-			throw Util.runtimeException(e.getCause());
-		else if(e.getCause() instanceof Error)
-			throw (Error) e.getCause();
-		throw Util.runtimeException(e);
-		}
+	return invokeStaticMethod(c, methodName, args);
 }
 
 public static Object invokeStaticMethod(Class c, String methodName, Object[] args) {
@@ -342,7 +325,7 @@ private static <T extends Object> int getMatchingParams(T member, ArrayList<Clas
 			if(aclass == pclass)
 				exact++;
 			else
-				match = Reflector.paramArgTypeMatch(pclass, aclass);
+				match = paramArgTypeMatch(pclass, aclass);
 			}
 		if(exact == argTypes.length)
             {
@@ -455,13 +438,6 @@ private static List<Method> getMethodsForName(Class c, String name, Statics stat
 				{
 				}
 			}
-//			   && (!method.isBridge()
-//			       || (c == StringBuilder.class &&
-//			          c.getMethod(method.getName(), method.getParameterTypes())
-//					.equals(method))))
-//				{
-//				methods.add(allmethods[i]);
-//				}
 		}
 
 	if(methods.isEmpty())
@@ -574,24 +550,6 @@ private static boolean paramArgTypeMatch(Class paramType, Class argType){
 	return false;
 }
 
-private static boolean isCongruent(Class[] params, Object[] args){
-	boolean ret = false;
-	if(args == null)
-		return params.length == 0;
-	if(params.length == args.length)
-		{
-		ret = true;
-		for(int i = 0; ret && i < params.length; i++)
-			{
-			Object arg = args[i];
-			Class argType = (arg == null) ? null : arg.getClass();
-			Class paramType = params[i];
-			ret = paramArgTypeMatch(paramType, argType);
-			}
-		}
-	return ret;
-}
-
 public static Object prepRet(Class c, Object x){
 	if (!(c.isPrimitive() || c == Boolean.class))
 		return x;
-- 
1.7.3.5


From 9d4c4d96a6b15fe3e04f3faf3ede9c3e0def761d Mon Sep 17 00:00:00 2001
From: Andy Fingerhut <andy_fingerhut@alum.wustl.edu>
Date: Mon, 20 Feb 2012 10:54:56 -0800
Subject: [PATCH 20/20] Move EMPTY_TYPES definition later so code will compile.

---
 src/jvm/clojure/lang/Compiler.java |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index 68253a6..a990fbd 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -432,8 +432,6 @@ static class DefExpr implements Expr{
 		return Var.class;
 	}
 
-    private static final Class[] EMPTY_TYPES = new Class[0];
-
     static class Parser implements IParser{
 		public Expr parse(C context, Object form) {
 			//(def x) or (def x initexpr) or (def x "docstring" initexpr)
@@ -861,6 +859,8 @@ static public abstract class HostExpr implements Expr, MaybePrimitiveExpr{
 			}
 	}
 
+        private static final Class[] EMPTY_TYPES = new Class[0];
+
 	static class Parser implements IParser{
 		public Expr parse(C context, Object frm) {
 			ISeq form = (ISeq) frm;
-- 
1.7.3.5

