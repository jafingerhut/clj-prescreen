From f5babb53c4a527d93d6e34c91d7c23e4b4b9505e Mon Sep 17 00:00:00 2001
From: Andy Fingerhut <andy_fingerhut@alum.wustl.edu>
Date: Fri, 23 Mar 2012 18:00:53 -0700
Subject: [PATCH] Make into, select-keys, clojure.set/project, and
 clojure.set/rename preserve metadata

---
 src/clj/clojure/core.clj               |    4 +-
 src/clj/clojure/set.clj                |    4 +-
 test/clojure/test_clojure/metadata.clj |  123 +++++++++++++++++++++++++++++++-
 3 files changed, 126 insertions(+), 5 deletions(-)

diff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj
index 9cf45e6..f5692ad 100644
--- a/src/clj/clojure/core.clj
+++ b/src/clj/clojure/core.clj
@@ -1444,7 +1444,7 @@
              (conj ret entry)
              ret)
            (next keys)))
-        ret)))
+        (with-meta ret (meta map)))))
 
 (defn keys
   "Returns a sequence of the map's keys."
@@ -6039,7 +6039,7 @@
    :static true}
   [to from]
   (if (instance? clojure.lang.IEditableCollection to)
-    (persistent! (reduce conj! (transient to) from))
+    (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))
     (reduce conj to from)))
 
 (defn mapv
diff --git a/src/clj/clojure/set.clj b/src/clj/clojure/set.clj
index 69233ad..87a372b 100644
--- a/src/clj/clojure/set.clj
+++ b/src/clj/clojure/set.clj
@@ -72,7 +72,7 @@
   "Returns a rel of the elements of xrel with only the keys in ks"
   {:added "1.0"}
   [xrel ks]
-    (set (map #(select-keys % ks) xrel)))
+  (with-meta (set (map #(select-keys % ks) xrel)) (meta xrel)))
 
 (defn rename-keys
   "Returns the map with the keys in kmap renamed to the vals in kmap"
@@ -90,7 +90,7 @@
   "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"
   {:added "1.0"}
   [xrel kmap]
-    (set (map #(rename-keys % kmap) xrel)))
+  (with-meta (set (map #(rename-keys % kmap) xrel)) (meta xrel)))
 
 (defn index
   "Returns a map of the distinct values of ks in the xrel mapped to a
diff --git a/test/clojure/test_clojure/metadata.clj b/test/clojure/test_clojure/metadata.clj
index 6bd9bbb..6fbc316 100644
--- a/test/clojure/test_clojure/metadata.clj
+++ b/test/clojure/test_clojure/metadata.clj
@@ -10,7 +10,8 @@
 
 (ns clojure.test-clojure.metadata
   (:use clojure.test
-        [clojure.test-helper :only (eval-in-temp-ns)]))
+        [clojure.test-helper :only (eval-in-temp-ns)])
+  (:require [clojure.set :as set]))
 
 (def public-namespaces
   '[clojure.core
@@ -85,3 +86,123 @@
         (is (eval-in-temp-ns
              (defn foo ^long [^long x] x)
              (def x (foo (inc 10)))))))))
+ 
+ (deftest fns-preserve-metadata-on-maps
+   (let [xm {:a 1 :b -7}
+         x (with-meta {:foo 1 :bar 2} xm)
+         ym {:c "foo"}
+         y (with-meta {:baz 4 :guh x} ym)]
+ 
+     (is (= xm (meta (:guh y))))
+     (is (= xm (meta (reduce #(assoc %1 %2 (inc %2)) x (range 1000)))))
+     (is (= xm (meta (-> x (dissoc :foo) (dissoc :bar)))))
+     (let [z (assoc-in y [:guh :la] 18)]
+       (is (= ym (meta z)))
+       (is (= xm (meta (:guh z)))))
+     (let [z (update-in y [:guh :bar] inc)]
+       (is (= ym (meta z)))
+       (is (= xm (meta (:guh z)))))
+     (is (= xm (meta (get-in y [:guh]))))
+     (is (= xm (meta (into x y))))
+     (is (= ym (meta (into y x))))
+     
+     (is (= xm (meta (merge x y))))
+     (is (= ym (meta (merge y x))))
+     (is (= xm (meta (merge-with + x y))))
+     (is (= ym (meta (merge-with + y x))))
+ 
+     (is (= xm (meta (select-keys x [:bar]))))
+     (is (= xm (meta (set/rename-keys x {:foo :new-foo}))))
+ 
+     ;; replace returns a seq when given a set.  Can seqs have
+     ;; metadata?
+     
+     ;; TBD: rseq, subseq, and rsubseq returns seqs.  If it is even
+     ;; possible to put metadata on a seq, does it make sense that the
+     ;; seqs returned by these functions should have the same metadata
+     ;; as the sorted collection on which they are called?
+     ))
+ 
+ (deftest fns-preserve-metadata-on-vectors
+   (let [xm {:a 1 :b -7}
+         x (with-meta [1 2 3] xm)
+         ym {:c "foo"}
+         y (with-meta [4 x 6] ym)]
+ 
+     (is (= xm (meta (y 1))))
+     (is (= xm (meta (assoc x 1 "one"))))
+     (is (= xm (meta (reduce #(conj %1 %2) x (range 1000)))))
+     (is (= xm (meta (pop (pop (pop x))))))
+     (let [z (assoc-in y [1 2] 18)]
+       (is (= ym (meta z)))
+       (is (= xm (meta (z 1)))))
+     (let [z (update-in y [1 2] inc)]
+       (is (= ym (meta z)))
+       (is (= xm (meta (z 1)))))
+     (is (= xm (meta (get-in y [1]))))
+     (is (= xm (meta (into x y))))
+     (is (= ym (meta (into y x))))
+ 
+     (is (= xm (meta (replace {2 "two"} x))))
+     (is (= [1 "two" 3] (replace {2 "two"} x)))
+ 
+     ;; TBD: Currently subvec drops metadata.  Should it preserve it?
+     ;;(is (= xm (meta (subvec x 2 3))))
+ 
+     ;; TBD: rseq returns a seq.  If it is even possible to put
+     ;; metadata on a seq, does it make sense that the seqs returned by
+     ;; these functions should have the same metadata as the sorted
+     ;; collection on which they are called?
+     ))
+ 
+ (deftest fns-preserve-metadata-on-sets
+   ;; TBD: Do tests independently for set, hash-set, and sorted-set,
+   ;; perhaps with a loop here.
+   (let [xm {:a 1 :b -7}
+         x (with-meta #{1 2 3} xm)
+         ym {:c "foo"}
+         y (with-meta #{4 x 6} ym)]
+ 
+     (is (= xm (meta (y #{3 2 1}))))
+     (is (= xm (meta (reduce #(conj %1 %2) x (range 1000)))))
+     (is (= xm (meta (-> x (disj 1) (disj 2) (disj 3)))))
+     (is (= xm (meta (into x y))))
+     (is (= ym (meta (into y x))))
+ 
+     (is (= xm (meta (set/select even? x))))
+     (let [cow1m {:what "betsy cow"}
+           cow1 (with-meta {:name "betsy" :id 33} cow1m)
+           cow2m {:what "panda cow"}
+           cow2 (with-meta {:name "panda" :id 34} cow2m)
+           cowsm {:what "all the cows"}
+           cows (with-meta #{cow1 cow2} cowsm)
+           cow-names (set/project cows [:name])
+           renamed (set/rename cows {:id :number})]
+       (is (= cowsm (meta cow-names)))
+       (is (= cow1m (meta (first (filter #(= "betsy" (:name %)) cow-names)))))
+       (is (= cow2m (meta (first (filter #(= "panda" (:name %)) cow-names)))))
+       (is (= cowsm (meta renamed)))
+       (is (= cow1m (meta (first (filter #(= "betsy" (:name %)) renamed)))))
+       (is (= cow2m (meta (first (filter #(= "panda" (:name %)) renamed))))))
+ 
+     ;; replace returns a seq when given a set.  Can seqs have
+     ;; metadata?
+ 
+     ;; union: Currently returns the metadata of the largest input set.
+     ;; This is an artifact of union's current implementation.  I doubt
+     ;; any explicit design decision was made to do so.  Like join,
+     ;; there doesn't seem to be much reason to prefer the metadata of
+     ;; one input set over another, if at least two input sets are
+     ;; given, but perhaps defining it to always return a set with the
+     ;; metadata of the first input set would be reasonable?
+ 
+     ;; intersection: Returns metadata of the smallest input set.
+     ;; Otherwise similar to union.
+ 
+     ;; difference: Seems to always return a set with metadata of first
+     ;; input set.  Seems reasonable.  Not sure we want to add a test
+     ;; for it, if it is an accident of the current implementation.
+ 
+     ;; join, index, map-invert: Currently always returns a value with
+     ;; no metadata.  This seems reasonable.
+     ))
-- 
1.7.9.2

