diff --git a/src/clj/clojure/core_proxy.clj b/src/clj/clojure/core_proxy.clj
index 830f5ce..e448afc 100644
--- a/src/clj/clojure/core_proxy.clj
+++ b/src/clj/clojure/core_proxy.clj
@@ -369,6 +369,21 @@
   [meth & args]
  `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))
 
+(defn- public-version-of-method [^java.lang.reflect.Method method]
+  "returns a Method built against a public interface or superclass
+  declaring this method, or nil if none exists"
+  (let [sig (method-sig method)]
+    (loop [current-class (. method (getDeclaringClass))
+	   pending-supers (seq (supers current-class))]
+      (if (and current-class
+	       (java.lang.reflect.Modifier/isPublic (. current-class (getModifiers)))
+               (some #(= sig (method-sig %)) (. current-class (getDeclaredMethods))))
+        (. current-class (getDeclaredMethod (.getName method) (.getParameterTypes method)))
+	(if pending-supers
+	  (recur (first pending-supers)
+		 (next pending-supers))
+          nil)))))
+
 (defn bean
   "Takes a Java object and returns a read-only implementation of the
   map abstraction based upon its JavaBean properties."
@@ -377,9 +392,15 @@
   (let [c (. x (getClass))
 	pmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]
 			 (let [name (. pd (getName))
-			       method (. pd (getReadMethod))]
-			   (if (and method (zero? (alength (. method (getParameterTypes)))))
-			     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))
+			       method (. pd (getReadMethod))
+                               is-zero-args (zero? (alength (. method (getParameterTypes))))
+                               public-method (and is-zero-args
+                                                  (or (and (java.lang.reflect.Modifier/isPublic (. c (getModifiers)))
+                                                           method)
+                                                      (public-version-of-method method)))
+			       ]
+			   (if public-method
+			     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. public-method (invoke x nil)))))
 			     m)))
 		     {}
 		     (seq (.. java.beans.Introspector
diff --git a/test/clojure/test_clojure/java_interop.clj b/test/clojure/test_clojure/java_interop.clj
index 55ab50f..fb6ce0f 100644
--- a/test/clojure/test_clojure/java_interop.clj
+++ b/test/clojure/test_clojure/java_interop.clj
@@ -125,6 +125,10 @@
 
         (:class b) java.awt.Color )))
 
+(deftest test-bean-private-instances
+  (testing "That bean works with private objects"
+    (let [b (bean (bean_reflection.BeanReflectionTest/getImplementation))]
+      (is (= "foo" (:foo b))))))
 
 ; proxy, proxy-super
 
diff --git a/test/java/clojure/test/bean_reflection/BeanReflectionTest.java b/test/java/clojure/test/bean_reflection/BeanReflectionTest.java
new file mode 100644
index 0000000..47c8306
--- /dev/null
+++ b/test/java/clojure/test/bean_reflection/BeanReflectionTest.java
@@ -0,0 +1,9 @@
+package bean_reflection;
+
+public class BeanReflectionTest {
+
+	public static BeanReflectionTestImpl getImplementation() {
+		return new BeanReflectionTestImpl();
+	}
+
+}
diff --git a/test/java/clojure/test/bean_reflection/BeanReflectionTestImpl.java b/test/java/clojure/test/bean_reflection/BeanReflectionTestImpl.java
new file mode 100644
index 0000000..592e199
--- /dev/null
+++ b/test/java/clojure/test/bean_reflection/BeanReflectionTestImpl.java
@@ -0,0 +1,9 @@
+package bean_reflection;
+
+/* NOT PUBLIC */
+
+class BeanReflectionTestImpl implements IBeanReflectionTest {
+	public String getFoo() {
+		return "foo";
+	}
+}
diff --git a/test/java/clojure/test/bean_reflection/IBeanReflectionTest.java b/test/java/clojure/test/bean_reflection/IBeanReflectionTest.java
new file mode 100644
index 0000000..086ed71
--- /dev/null
+++ b/test/java/clojure/test/bean_reflection/IBeanReflectionTest.java
@@ -0,0 +1,5 @@
+package bean_reflection;
+
+public interface IBeanReflectionTest {
+	public String getFoo();
+}
